<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Single-Image Neural Network</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
</head>
<body>
<h1>Image Neural Network Training</h1>
<input type="file" id="fileInput" accept="image/*"><br><br>
<canvas id="inputCanvas" style="display:none;"></canvas>
<canvas id="outputCanvas"></canvas><br><br>
<button id="trainButton">Train & Predict</button>

<script>
const inputCanvas = document.getElementById('inputCanvas');
const outputCanvas = document.getElementById('outputCanvas');
const fileInput = document.getElementById('fileInput');
const trainButton = document.getElementById('trainButton');

let model;
let imageTensor;

// Load and preprocess the image
fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const img = new Image();
    img.src = URL.createObjectURL(file);
    img.onload = () => {
        const ctx = inputCanvas.getContext('2d');
        inputCanvas.width = img.width;
        inputCanvas.height = img.height;
        outputCanvas.width = img.width;
        outputCanvas.height = img.height;
        ctx.drawImage(img, 0, 0, img.width, img.height);

        // Convert the image to grayscale
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const grayscaleData = new Float32Array(img.width * img.height);
        for (let i = 0; i < grayscaleData.length; i++) {
            const r = imageData.data[i * 4];
            grayscaleData[i] = r / 255; // Assuming grayscale image, take red channel
        }
        imageTensor = tf.tensor2d(grayscaleData, [img.height, img.width]);
    };
});

// Define the model
function createModel() {
    const input = tf.input({ shape: [1], name: 'input' });
    const denseLayer = tf.layers.dense({
        units: 5 * 5,
        useBias: false,
        kernelInitializer: 'randomNormal'
    });
    const reshape = tf.layers.reshape({ targetShape: [5, 5, 1] });
    const convLayer = tf.layers.conv2d({
        filters: 1,
        kernelSize: [2, 2],
        padding: 'valid',
        activation: 'linear',
        kernelInitializer: 'randomNormal'
    });

    let output = denseLayer.apply(input);
    output = reshape.apply(output);
    output = tf.image.resizeBilinear(output, [15, 15]); // Bilinear upscaling by 3
    output = convLayer.apply(output);
    output = tf.image.resizeBilinear(output, [imageTensor.shape[0], imageTensor.shape[1]]);
    return tf.model({ inputs: input, outputs: output });
}

// Train and predict
trainButton.addEventListener('click', async () => {
    if (!imageTensor) {
        alert("Please load an image first!");
        return;
    }

    // Create the model and compile it
    model = createModel();
    model.compile({
        optimizer: tf.train.adam(),
        loss: 'meanSquaredError'
    });

    // Reshape the image tensor for training
    const xs = tf.ones([1, 1]); // Input is a single value, as per the structure
    const ys = imageTensor.expandDims(-1).expandDims(0); // Output should match image dimensions

    // Train the model
    await model.fit(xs, ys, {
        epochs: 10,
        batchSize: 1,
    });

    // Predict the output and display it
    const prediction = model.predict(xs).squeeze();
    const predictedData = prediction.dataSync();
    const ctx = outputCanvas.getContext('2d');
    const outputImageData = ctx.createImageData(outputCanvas.width, outputCanvas.height);
    for (let i = 0; i < predictedData.length; i++) {
        const value = predictedData[i] * 255;
        outputImageData.data[i * 4] = value;
        outputImageData.data[i * 4 + 1] = value;
        outputImageData.data[i * 4 + 2] = value;
        outputImageData.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(outputImageData, 0, 0);
});
</script>
</body>
</html>
