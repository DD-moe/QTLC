<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Quantity TLC Image Processor - A scientific web app for analyzing and processing Thin Layer Chromatography (TLC) images with precision and efficiency.">
  <meta name="keywords" content="TLC image processing, Thin Layer Chromatography, scientific web app, image analysis, chromatography tools, web-based TLC analysis, no installation TLC software, client-side image analysis, smartphone TLC processor, UV chamber analysis, TLC plate analysis, lightweight TLC app, first online TLC tool, serverless chromatography, portable TLC image processor, TLC for mobile devices, instant TLC quantification, web app for TLC quantification, TLC analysis anywhere, innovative TLC tools, online chromatography software">
  <meta name="author" content="Damian Bezara">
  <meta name="robots" content="index, follow">
  <title>Quantity TLC Image Processor</title>
  <style>
 /* General Body Styling */
body {
  font-family: 'Roboto', Arial, sans-serif;
  padding: 2em;
  margin: 0;
  background-color: #ccd4e3;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  color: #333;
  line-height: 1.6;
}

br {
    line-height: 0; /* Removes extra spacing */
    margin: 0;      /* Ensures no margin is added */
    display: block; /* Ensures it still acts as a block-level element */
  }

  #modelListContainer {  /* Container for the list */
    max-height: 20vh; /* Maximum height of the container (20% of viewport height) */
    border: 1px solid #ccc;
    overflow-y: auto; /* Enable vertical scrolling */
    padding: 0.5rem;
    margin-bottom: 1rem;
    width: 80%;
}

ul {
    list-style-type: none;
    padding: 0;
    margin: 0; /* Reset default ul margins */
}

li {
    cursor: pointer;
    padding: 0.5rem;
    border-bottom: 1px solid #eee;
    transition: background-color 0.2s ease; /* Smooth hover transition */
}

li:hover {
    background-color: #f5f5f5; /* Slightly lighter background on hover */
}

li:last-child { /*Remove border from last element*/
    border-bottom: none;
}

/* Input Fields */
input {
  margin: 0.4em 0;
  padding: 0.2em;
  font-size: 1.5em;
  border: 1px solid blueviolet;
  background-color: #d4c8d8;
  border-radius: 4px;
  width: 100%;
  max-width: 400px;
  text-align: center;
}

/* Textarea Styling */
textarea {
  margin: 0.4em 0;
  padding: 0.2em;
  font-size: 1.5em;
  border: 1px solid blueviolet;
  background-color: #d4c8d8;
  border-radius: 4px;
  width: 100%;
  max-width: 400px;
  text-align: left;
  resize: vertical; /* Allow vertical resizing */
  height: 100px; /* Default height */
}

/* Canvas Elements */
#loadingCanvasContainer {
  display: none;
}

#raportCanvas{
  display: none;
}

#background-canvas, #data-canvas{
  max-width: 100%;
  height: auto;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  border: 1px solid #ff0080;
  border-radius: 5px;
  background-color: #fff;
}

.preview-canvas {
  display: block;
  margin-top: 1em;
  border: 1px solid #007BFF;
  border-radius: 5px;
  background-color: #fff;
  width: 100%;
  max-width: 500px;
  height: auto;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Buttons */
button {
  padding: 0.3em 0.7em;
  font-size: 1.5em;
  font-weight: bold;
  cursor: pointer;
  background-color: #007BFF;
  color: white;
  border: none;
  border-radius: 5px;
  margin: 0.5em auto;
  transition: background-color 0.3s ease;
  display: block;
  text-align: center;
}

button:hover {
  background-color: #0056b3;
}

/* Data Container */
#data-container {
  width: 100%;
  max-width: 800px;
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  border: 1px solid #ccc;
  border-radius: 5px;
  background-color: #fff;
  margin: 0.6em 0;
  padding: 0.4em;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Table Styling */
table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: center;
  font-size: 1.2em;
}

th {
  background-color: #f4f4f4;
  font-weight: bold;
}

tr:nth-child(even) {
  background-color: #f9f9f9;
}

tr:hover {
  background-color: #f1f1f1;
}

/* Labels and Text */
label {
  font-weight: bold;
  margin-bottom: 0.2em;
  display: block;
  font-size: 1.2em;
}

p {
  margin: 0.4em 0;
  font-size: 1.2em;
  color: #555;
}

span {
  font-weight: bold;
  color: #26173d;
  font-size: 1.1em;
  text-align: left;
}

em {
  font-style: italic;
  color: #26173d;
  font-size: 0.7em;
  margin-left: 0.5em;
  display: block;
  text-align: center;
}

/* Headings */
h1, h2 {
  margin: 0.2em 0;
  text-align: center;
  font-weight: bold;
  color: #007BFF;
}

h1 {
  font-size: 2em;
}

h2 {
  font-size: 1.8em;
}

h2 {
  font-size: 1.6em;
  color: #26173d;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  body {
    padding: 0.3em;
  }
  

  button {
    width: 100%;
    max-width: 300px;
  }

  #data-container {
    width: 100%;
    max-width: 100%;
    font-size: 0.9em;
  }
}

.slider {
    width: 95%;
    margin: 0.2em 0;
  }

  input[type="checkbox"] {
    height: 1em;
    width: 1em;
  }

  .section_border {
      border: 0.2em solid #3f3a3a;
      border-radius: 5px;
      background-color: #ffffff;
      margin: 10px 0;
      padding: 10px;
      box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
      width: 90%;
    }

    .section_border h3 {
      margin: 0;
      font-size: 1.2em;
      color: #ffffff;
      background-color: #3f3a3a;
      padding: 10px;
      border-radius: 3px;
      cursor: pointer;
      text-align: center;
    }

    .section {
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
    }

.pdf {
    padding: 0;
    margin: 0;
    width: 100%;
    background-color: white;


    font-size: 12px;
    line-height: 1.5;
    box-sizing: border-box;
    border: none;
}


.pdf h1, 
.pdf h2, 
.pdf h3 {
    margin: 0;
    font-weight: bold;
    text-align: center;
    background-color: white;
    color: black;
}

.pdf h1 {
    font-size: 24px;
    margin: 0;
}

.pdf h2 {
    font-size: 20px;
    margin: 0;
}

.pdf h3 {
    font-size: 16px;
    margin: 0;
}

.pdf p {
    margin: 0;
    text-align: justify;
}

.pdf span {
    margin: 0;
    text-align: justify;
}

.pdf img {
    max-width: 95%; /* Scale images to fit the container */
    height: auto;
    margin: 10px auto;
    display: inline-block;
}

.pdf table {
    width: 95%;
    border-collapse: collapse;
    margin: 15px 0;
    font-size: 12px;
}

.pdf th, 
.pdf td {
    border: 1px solid #ccc;
    padding: 8px;
    text-align: left;
}

.pdf th {
    background-color: #f4f4f4;
    font-weight: bold;
}

.pdf tr:nth-child(even) {
    background-color: #f9f9f9;
}

.pdf tr:hover {
    background-color: #eaeaea;
}

div.page{
    margin: 0;
    width: 100%;
    box-sizing: border-box; /* Include padding in width/height */
    padding: 1em 1em 1em 1em;
}

  </style>
</head>
<body>

  <h1>Mobile Image Processor</h1>

  <!-- File Inputs -->
   <div class="section_border">
    <h3 onclick="toggleVisibility('s_inputs', 'section_border_title', 'auto')" name="Input Panel" id="section_border_title">(hide) Input Panel</h3>
    <div class="section" id="s_inputs">
      <label for="rotateRight90">Rotate images right by 90 deg.</label>
      <input type="checkbox" id="rotateRight90">
      <label for="flipHorizontally">Flip images horizontally</label>
      <input type="checkbox" id="flipHorizontally">
      <label for="data-file">Upload Data Image:</label>
      <input type="file" id="data-file" accept="image/*" multiple>
      <label for="background-file">Upload Background Image:</label>
      <input type="file" id="background-file" accept="image/*" multiple>
      <button id="reloadImages">Reload</button>
      <label for="percentageInput">Percent of darkest pixels to detect spot:</label>
      <input type="number" id="percentageInput" value="15" min="0" max="255">
      <label for="constTreshold">Use constant treshold instead percental</label>
      <input type="checkbox" id="constTreshold">
      <label for="showLoaded">Show Loaded Images</label>
      <input type="checkbox" id="showLoaded">
    </div>
</div>

  <!-- Slider -->
  <div class="section_border">
    <h3 onclick="toggleVisibility('slider_container', 'slider_container_title', 'auto')" name="Slider Panel" id="slider_container_title">(hide) Slider Panel</h3>
    <div id="slider_container" class="section">
      <label for="slider_X">Box Size X: <span id="slider-value_X">50</span></label>
      <input type="range" id="slider_X" min="30" max="150" value="50" class="slider"><br>
      <label for="slider_Y">Box Size Y: <span id="slider-value_Y">50</span></label>
      <input type="range" id="slider_Y" min="30" max="150" value="50" class="slider"><br>      
      <label for="slider_L">Shift left: <span id="slider-value_L">0</span></label>
      <input type="range" id="slider_L" min="-50" max="50" value="0" class="slider"><br>   
      <label for="slider_T">Shift top: <span id="slider-value_T">0</span></label>
      <input type="range" id="slider_T" min="-50" max="50" value="0" class="slider">
      <label for="chart_blurr">Chart Blurr kernel size</label>
      <input type="number" id="chart_blurr" min="1" max="10" value="5">     
      <label for="borderTreshold">Treshold for valley detection in %</label>
      <input type="number" id="borderTreshold" min="0" max="5" value="1">    
      <label for="kernelValleyTreshols">Kernel for valley detection in pixels</label>
      <input type="number" id="kernelValleyTreshols" min="1" max="5" value="3">       
    </div>
</div>


  <!-- Processing site -->
  <button id="process-button">Process</button>
  <h2 id="predictionBox">Predicted value: </h2>
  <label for="measurmentComment">Measurement name or comment</label>
  <input type="text" id="measurmentComment">   


  <!-- Hidden Canvases -->
   <div id="loadingCanvasContainer">
    <p>Image with track / spot</p>
    <canvas id="data-canvas"></canvas>
    <p>Image with background</p>
    <canvas id="background-canvas"></canvas>
  </div>

  <!-- Preview Canvas -->
  <div class="section_border">
    <h3 onclick="toggleVisibility('outcome_container', 'outcome_container_title', 'auto')" name="Result Panel" id="outcome_container_title">(hide) Result Panel</h3>
    <div id="outcome_container" class="section">
      <canvas id="preview-canvas" class="preview-canvas"></canvas>
      <canvas id="chartCanvas" class="preview-canvas"></canvas>
      <div class="section_border">
        <div id="resultBox" class="section">Spot Parameters not ready yet</div>
      </div>
      <div class="section_border">
        <h3 onclick="toggleVisibility('PeakresultBox', 'PeakresultBox_title', 'auto')" name="Peak Panel" id="PeakresultBox_title">(hide) Peak Panel</h3>
        <div id="PeakresultBox" class="section">Peak Parameters not ready yet</div>
      </div>
  </div>
</div>

<div class="section_border">
  <h3 onclick="toggleVisibility('curve_container', 'curve_container_title', 'auto')" name="Curve Panel" id="curve_container_title">(hide) Curve Panel</h3> 
  <div id="curve_container" class="section">
    <label for="useAUC">Use AUC instead of total spot pixels sum</label>
    <input type="checkbox" id="useAUC">    
    <label for="substance-concentration">Substance Concentration:</label>
    <input type="number" id="substance-concentration">
    <div id="buttonContainer">
      <button id="add-measurement">Add Measurement</button>
      <button onclick="createConcentrationCurve()">Create Concentration Curve</button>
      <button onclick="predictConcentration()">Predict Concentration</button>
    </div>
    <div id="formuldBox">Formula not ready yet</div><br>
    <div id="data-container"></div>
  </div>
</div>

<div class="section_border">
  <h3 onclick="toggleVisibility('model_container', 'model_container_title', 'auto')" name="Model Panel" id="model_container_title">(hide) Model Panel</h3> 
  <div id="model_container" class="section">  
    <label for="resolutionRatio">ratio to adjust to blueprint model</label>
    <input type="number" id="resolutionRatio" value="1">
    <button id="sharableData_paste">Paste model data</button>
    <button id="sharableData_copy">Copy model data</button>
    <label for="substanceName">Substance name</label>
    <input type="text" id="substanceName">
    <label for="modelName">Model Name:</label>
    <input type="text" id="modelName">    
    <label for="modelComment">model description</label>
    <textarea id="modelComment"></textarea>
<!-- color inputs /--> 
<label for="redFactor">Red channel multiplyer</label>
<input type="number" id="redFactor" min="0" max="1" value="0.2126" step="0.0001">     
<label for="greenFactor">Green channel multiplyer</label>
<input type="number" id="greenFactor" min="0" max="1" value="0.7152" step="0.0001">    
<label for="blueFactor">Blue channel multiplyer</label>
<input type="number" id="blueFactor" min="0" max="1" value="0.0722" step="0.0001">    
<!-- moddels panel -->
<button id="saveModel">Save Model</button>
<input type="text" id="modelSearch" placeholder="Search models...">
<div id="modelListContainer">
  <ul id="modelList"></ul>
</div>
<button id="copyAllModels">Copy All Models</button>
<button id="pasteAllModels">Paste All Models</button>
    <button id="deleteModel">Delete Model</button>
    <button id="applyModel">Apply Model</button>
  </div>
</div>
<!-- report section -->
<div class="section_border">
  <h3 onclick="toggleVisibility('raport_container', 'raport_container_title', 'auto')" name="Raport Panel" id="raport_container_title">(hide) Raport Panel</h3> 
  <div id="raport_container" class="section">
    <label for="RaportName">Raport file name</label>
    <input type="text" id="RaportName"> 
    <button id="recordButton">Start Recording Report</button>
    <button id="clearButton">Clear Report</button>
    <button id="savePdfButton">Save as PDF</button>
    <button id="shareButton">Share PDF</button>

    <!-- report params section -->
    <div class="section_border">
      <h3 onclick="toggleVisibility('ReportSettings_container', 'ReportSettings_container_title', 'auto')" name="Report Settings Panel" id="ReportSettings_container_title">(hide) Report Settings Panel</h3>
      <div id="ReportSettings_container" class="section">
        <label for="includeImages">Include visual images (e.g., graphs, charts) in the PDF report</label>
        <input type="checkbox" id="includeImages"> 
        <label for="useLossless">Select lossless PNG format for high-quality images in the PDF</label>
        <span>(If unchecked: jpg with 70% quality is used)</span>
        <input type="checkbox" id="useLossless"> 
        <label for="includeParams">Include chromatographic parameters and data for qualitative analysis</label>
        <input type="checkbox" id="includeParams"> 
        <label for="includeExplanations">Include explanations and interpretations generated by the program</label>
        <input type="checkbox" id="includeExplanations">
        <label for="includeMetadata">Include metadata such as date, time, author, and version information</label>
        <input type="checkbox" id="includeMetadata">
        <label for="includeSummary">Add a summary section to the report</label>
        <input type="checkbox" id="includeSummary">        
      </div>
    </div>

    <div id="report-content" class="pdf"></div>
    <canvas id="raportCanvas"></canvas>
  </div>
</div>

<!-- other scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/print-js@1.6.0/dist/print.min.js"></script>

<!-- other scripts -->

  <script>
    // inputs
    const dataInput = document.getElementById('data-file');
    const backgroundInput = document.getElementById('background-file');
    const rotateRight90 = document.getElementById('rotateRight90');
    const flipHorizontally = document.getElementById('flipHorizontally');
    const loadingCanvasContainer = document.getElementById('loadingCanvasContainer');
    // sliders
    const slider_X = document.getElementById('slider_X');
    const sliderValue_X = document.getElementById('slider-value_X');
    const slider_Y = document.getElementById('slider_Y');
    const sliderValue_Y = document.getElementById('slider-value_Y');    
    const slider_L = document.getElementById('slider_L');
    const sliderValue_L = document.getElementById('slider-value_L');
    const slider_T = document.getElementById('slider_T');
    const sliderValue_T = document.getElementById('slider-value_T');    
    // process
    const processButton = document.getElementById('process-button');
    const dataCanvas = document.getElementById('data-canvas');
    const dataCtx = dataCanvas.getContext('2d');
    const backgroundCanvas = document.getElementById('background-canvas');
    const bcgCtx = backgroundCanvas.getContext('2d');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const percentageInput = document.getElementById("percentageInput");
    const constTreshold = document.getElementById('constTreshold');
    const borderTreshold  = document.getElementById('borderTreshold');
    const kernelValleyTreshols = document.getElementById('kernelValleyTreshols');
    const resultBox = document.getElementById("resultBox");
    const PeakresultBox = document.getElementById("PeakresultBox");
    const useAUC = document.getElementById("useAUC");
    const concentrationInput = document.getElementById('substance-concentration');
    const predictionBox = document.getElementById('predictionBox');
    const sharableData_paste= document.getElementById('sharableData_paste');
    const sharableData_copy = document.getElementById('sharableData_copy');
    const resolutionRatio = document.getElementById('resolutionRatio');
    const modelComment = document.getElementById('modelComment');
    const substanceName = document.getElementById('substanceName');
    const chart_blurr = document.getElementById('chart_blurr');
    const reloadImages = document.getElementById('reloadImages');
    const showLoaded = document.getElementById('showLoaded');
    const chartCanvas = document.getElementById('chartCanvas');
    // containers
    const model_container = document.getElementById('model_container');
    const curve_container = document.getElementById('curve_container');
    const outcome_container = document.getElementById('outcome_container');
    const slider_container = document.getElementById('slider_container');
    const s_inputs = document.getElementById('s_inputs');
    const redFactor = document.getElementById('redFactor');
    const greenFactor = document.getElementById('greenFactor');
    const blueFactor = document.getElementById('blueFactor');
    // models management:
    const modelNameInput = document.getElementById('modelName');
    const saveButton = document.getElementById('saveModel');
    const modelList = document.getElementById('modelList');
    const modelSearch = document.getElementById('modelSearch');
    const copyAllButton = document.getElementById('copyAllModels');
    const pasteAllButton = document.getElementById('pasteAllModels');
    const deleteButton = document.getElementById('deleteModel');
    const applyButton = document.getElementById('applyModel'); // Get the new button
    const MODEL_PREFIX = 'model_'; // Prefix for model keys
    // raport management
    let isRecording = false;
    const raportColor = '#ccd4e3';
    let reportContent = document.getElementById('report-content');
    const recordButton = document.getElementById('recordButton');
    const clearButton = document.getElementById('clearButton');
    const savePdfButton = document.getElementById('savePdfButton');
    const shareButton = document.getElementById('shareButton'); 
    const RaportName = document.getElementById('RaportName'); 
    const raportCanvas = document.getElementById('raportCanvas'); 
    const measurmentComment = document.getElementById('measurmentComment');
    // report settings
    const ReportSettings_container = document.getElementById('ReportSettings_container');
    const includeImages = document.getElementById('includeImages');
    const useLossless = document.getElementById('useLossless');
    const includeParams = document.getElementById('includeParams');
    const includeExplanations = document.getElementById('includeExplanations');
    const includeMetadata = document.getElementById('includeMetadata');
    const includeSummary = document.getElementById('includeSummary');

    let current_sum = 0;
    const measurements = []; // 2D array for storing data
    current_curve = {}; // object to store linear reggression formula

    sharableData_paste.addEventListener("click",  () => {setSharableData(true)});
    sharableData_copy.addEventListener("click",  getSharableData);

    function toggleVisibility(ID, tittle_ID, mode) {
      const section = document.getElementById(ID);
      const tittle = document.getElementById(tittle_ID);
      if (mode == 'auto') {
        if (section.style.display === "none") {
        section.style.display = "flex"; // Show the element
        tittle.textContent = `(hide) ${tittle.getAttribute("name")}`
      } else {
        section.style.display = "none"; // Hide the element
        tittle.textContent = `(show) ${tittle.getAttribute("name")}`
      }
      } else {
        if (mode == 'flex') {
          section.style.display = "flex"; // Show the element
          tittle.textContent = `(hide) ${tittle.getAttribute("name")}`          
        }
        if (mode == 'none') {
          section.style.display = "none"; // Hide the element
          tittle.textContent = `(show) ${tittle.getAttribute("name")}`         
        }
      }
    }


    // Update sliders value display
    slider_X.addEventListener('input', () => {
      sliderValue_X.textContent = slider_X.value;
    });
    slider_Y.addEventListener('input', () => {
      sliderValue_Y.textContent = slider_Y.value;
    });    
    slider_L.addEventListener('input', () => {
      sliderValue_L.textContent = slider_L.value;
    });
    slider_T.addEventListener('input', () => {
      sliderValue_T.textContent = slider_T.value;
    });    

    // Update slider value display
    async function setSharableData(clipboard){
      try {
        let data = undefined;
        if (clipboard === true) {
          const clipboardText = await navigator.clipboard.readText();
          data = JSON.parse(clipboardText);
        }
        else{
          data = JSON.parse(clipboard);
        }

      current_curve = data.current_curve;
      resolutionRatio.value = data.resolutionRatio;
      modelComment.value = data.modelComment;
      substanceName.value = data.substanceName;
      percentageInput.value = data.percentageInput;
      constTreshold.checked = data.constTreshold;
      slider_X.value = data.slider_X;
      sliderValue_X.textContent = slider_X.value;
      slider_Y.value = data.slider_Y;
      sliderValue_Y.textContent = slider_Y.value;      
      slider_L.value = data.slider_L;
      sliderValue_L.textContent = slider_L.value;
      slider_T.value = data.slider_T;
      sliderValue_T.textContent = slider_T.value;
      chart_blurr.value = data.chart_blurr;
      rotateRight90.checked = data.rotateRight90;
      flipHorizontally.checked = data.flipHorizontally;
      borderTreshold.value = data.borderTreshold;
      kernelValleyTreshols.value = data.kernelValleyTreshols;
      useAUC.checked = data.useAUC;
      showLoaded.checked = data.showLoaded;
      redFactor.value = data.redFactor;
      greenFactor.value = data.greenFactor;
      blueFactor.value = data.blueFactor;
      RaportName.value = data.RaportName;
      measurmentComment.value = data.measurmentComment;
      includeImages.checked = data.includeImages;
      useLossless.checked = data.useLossless;
      includeParams.checked = data.includeParams;
      includeExplanations.checked = data.includeExplanations;
      includeMetadata.checked = data.includeMetadata;
      includeSummary.checked = data.includeSummary;
      displayFormula(current_curve, 'formuldBox');
      toggleVisibility('model_container', 'model_container_title', data.model_container);
      toggleVisibility('curve_container', 'curve_container_title', data.curve_container);
      toggleVisibility('outcome_container', 'outcome_container_title', data.outcome_container);
      toggleVisibility('slider_container', 'slider_container_title', data.slider_container);
      toggleVisibility('s_inputs', 'section_border_title', data.s_inputs);
      toggleVisibility('PeakresultBox', 'PeakresultBox_title', data.PeakresultBox);
      toggleVisibility('raport_container', 'raport_container_title', data.raport_container);
      toggleVisibility('ReportSettings_container', 'ReportSettings_container_title', data.ReportSettings_container);
      }
      catch(error){
        console.error('Error pasting from clipboard:', error);
        alert('Failed to paste from clipboard');
      }
    }

    async function getSharableData(clipboard = false) {
      try {
      const data = {
        current_curve : current_curve,
        resolutionRatio : resolutionRatio.value,
        modelComment : modelComment.value,
        substanceName : substanceName.value,
        percentageInput : percentageInput.value,
        constTreshold : constTreshold.checked,
        slider_X : slider_X.value,
        slider_Y : slider_Y.value,
        slider_L : slider_L.value,
        slider_T : slider_T.value,
        model_container : model_container.style.display,
        curve_container : curve_container.style.display,
        outcome_container : outcome_container.style.display,
        slider_container : slider_container.style.display,
        s_inputs : s_inputs.style.display,
        PeakresultBox: PeakresultBox.style.display,
        raport_container: raport_container.style.display,
        ReportSettings_container: ReportSettings_container.style.display,
        chart_blurr: chart_blurr.value,
        rotateRight90: rotateRight90.checked, 
        flipHorizontally: flipHorizontally.checked,
        borderTreshold: borderTreshold.value,
        kernelValleyTreshols: kernelValleyTreshols.value,
        useAUC: useAUC.checked,
        showLoaded : showLoaded.checked,
        redFactor : redFactor.value,
        greenFactor : greenFactor.value,
        blueFactor : blueFactor.value,
        RaportName : RaportName.value,
        measurmentComment: measurmentComment.value,
        includeImages: includeImages.checked,
        useLossless: useLossless.checked,
        includeParams: includeParams.checked,
        includeExplanations: includeExplanations.checked,
        includeMetadata: includeMetadata.checked,
        includeSummary: includeSummary.checked
      }
      const textData = JSON.stringify(data);
      if (clipboard) {
        await navigator.clipboard.writeText(textData);
      }
      return textData;
    }
    catch (error) {
      console.error('Error copying to clipboard:', error);
      alert('Failed to copy to clipboard');
    }
  }

    function loadImageToCanvas(input, canvas, rotateRight90, flipHorizontally) {
  input.style.color = "black";
  const files = input.files;
  if (!files || files.length === 0) return;

  const ctx = canvas.getContext('2d');

  if (files.length === 1) {
    // Handle single image case
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        let width = img.width;
        let height = img.height;

        // Adjust canvas size for rotation if needed
        if (rotateRight90) {
          canvas.width = height;
          canvas.height = width;
          ctx.translate(height, 0); // Move the origin to the top-right corner
          ctx.rotate(Math.PI / 2); // Rotate 90 degrees clockwise
        } else {
          canvas.width = width;
          canvas.height = height;
        }

        if (flipHorizontally) {
          ctx.scale(-1, 1); // Flip horizontally
          ctx.translate(-width, 0); // Adjust the origin back
        }

        // Draw the image to the canvas
        ctx.drawImage(img, 0, 0);
        input.style.color = "green";
      };

      img.src = reader.result;
    };
    reader.readAsDataURL(files[0]);
    return;
  }

let combinedImageData = null;
let combinedFloatData = null;
let processedImages = 0;

Array.from(files).forEach((file, index) => {
  const reader = new FileReader();

  reader.onload = () => {
    const img = new Image();

    img.onload = () => {
      let width = img.width;
      let height = img.height;

      if (index === 0) {
        // Adjust canvas size for rotation if needed
        if (rotateRight90) {
          canvas.width = height;
          canvas.height = width;
          ctx.translate(height, 0); // Move the origin to the top-right corner
          ctx.rotate(Math.PI / 2); // Rotate 90 degrees clockwise
        } else {
          canvas.width = width;
          canvas.height = height;
        }

        if (flipHorizontally) {
          ctx.scale(-1, 1); // Flip horizontally
          ctx.translate(-width, 0); // Adjust the origin back
        }
      } else if (canvas.width !== (rotateRight90 ? height : width) || canvas.height !== (rotateRight90 ? width : height)) {
        console.error("All images must have the same dimensions.");
        input.style.color = "red";
        return;
      }

      // Draw the current image to the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      // Get the image data of the current image
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Initialize combinedFloatData and combinedImageData if it's the first image
      if (!combinedFloatData) {
        combinedFloatData = new Float32Array(imageData.data.length);
        for (let i = 0; i < combinedFloatData.length; i++) {
          combinedFloatData[i] = 0;
        }
        combinedImageData = ctx.createImageData(canvas.width, canvas.height);
      }

      // Add the current image's data to combinedFloatData, excluding the alpha channel
      for (let i = 0; i < imageData.data.length; i += 4) {
        combinedFloatData[i] += imageData.data[i];       // Red
        combinedFloatData[i + 1] += imageData.data[i + 1]; // Green
        combinedFloatData[i + 2] += imageData.data[i + 2]; // Blue
        combinedFloatData[i + 3] = 255;                  // Alpha remains opaque
      }

      processedImages++;

      // If all images are processed, calculate the average and update the canvas
      if (processedImages === files.length) {
        for (let i = 0; i < combinedFloatData.length; i += 4) {
          combinedImageData.data[i] = combinedFloatData[i] / files.length;       // Red
          combinedImageData.data[i + 1] = combinedFloatData[i + 1] / files.length; // Green
          combinedImageData.data[i + 2] = combinedFloatData[i + 2] / files.length; // Blue
          combinedImageData.data[i + 3] = 255;                                    // Alpha
        }

        ctx.putImageData(combinedImageData, 0, 0);
        input.style.color = "green";
      }
    };

    img.src = reader.result;
  };

  reader.readAsDataURL(file);
});

}


    dataInput.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    backgroundInput.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));
    flipHorizontally.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    rotateRight90.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));

    flipHorizontally.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));
    rotateRight90.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));    
    reloadImages.addEventListener('click', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    reloadImages.addEventListener('click', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));

    showLoaded.addEventListener('change', () => {
    if (showLoaded.checked) {
      loadingCanvasContainer.style.display = 'block'; // Show the canvas container
    } else {
      loadingCanvasContainer.style.display = 'none'; // Hide the canvas container
    }
});

    // Process button action
    processButton.addEventListener('click', () => {
      // make info report page
      const imagesFormat = useLossless.checked ? 'png' : 'jpeg';
      const info_page = ReportaddPage();
      ReportaddText('New measurement type: "spot only analysis" was attempted', 'h3', info_page);
      if (measurmentComment.value.length > 0) {
        ReportaddText(`'${measurmentComment.value}'` , 'p', info_page);
      } 
      

      const boxSize_X = parseInt(slider_X.value, 10);
      const boxSize_Y = parseInt(slider_Y.value, 10);
      const boxShiftLeft = parseInt(slider_L.value);
      const boxShiftTop = parseInt(slider_T.value);
      const dataWidth = dataCanvas.width;
      const dataHeight = dataCanvas.height;

      const r = parseFloat(redFactor.value);
      const g = parseFloat(blueFactor.value);
      const b = parseFloat(blueFactor.value);

      if (dataWidth === 0 || dataHeight === 0) {
        alert('Please upload a data image first.');
        return;
      }

      // Calculate the box dimensions
      const boxHalf_X = Math.floor(boxSize_X / 2);
      const boxHalf_Y = Math.floor(boxSize_Y / 2);
      const centerX = Math.floor(dataWidth / 2);
      const centerY = Math.floor(dataHeight / 2);
      const startX = centerX - boxHalf_X - boxShiftLeft;
      const startY = centerY - boxHalf_Y - boxShiftTop;

      // Draw the box to the preview canvas
      previewCanvas.width = boxSize_X;
      previewCanvas.height = boxSize_Y;
      // get image data prepared to normalzation
      const imageData = dataCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);
      const grayData = toGrayscale(imageData, r, g, b);
      previewCtx.putImageData(grayData, 0, 0);
      previewCtx.filter = 'blur(2px)'; // Set blur amount (e.g., 5px)
      previewCtx.drawImage(previewCanvas, 0, 0);   
      previewCtx.filter = 'none';
      const readyData = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);

      // get image data prepared to normalzation
      const bcgData = bcgCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);      
      const grayBcg = toGrayscale(bcgData, r, g, b);
      previewCtx.putImageData(grayBcg, 0, 0);
      previewCtx.filter = 'blur(5px)'; // Set blur amount (e.g., 5px)
      previewCtx.drawImage(previewCanvas, 0, 0);   
      previewCtx.filter = 'none';
      const readyBcg = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);
      const normalised = divideImageDataAndNormalize(readyData, readyBcg);
      // raport image:
      if (includeImages.checked) {
        const image_page = ReportaddPage();
        ReportaddText('spot cutted image:', 'p', image_page);
        ReportaddImage(imageData, imagesFormat, image_page);
        ReportaddText('spot cutted image - grayscale:', 'p', image_page);
        ReportaddImage(grayData, imagesFormat, image_page);
        ReportaddText('spot cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
        ReportaddImage(readyData, imagesFormat, image_page);          
        ReportaddText('background cutted image:', 'p', image_page);
        ReportaddImage(bcgData, format = imagesFormat, image_page);
        ReportaddText('background cutted image - grayscale:', 'p', image_page);
        ReportaddImage(grayBcg, format = imagesFormat, image_page);
        ReportaddText('background cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
        ReportaddImage(readyBcg, format = imagesFormat, image_page);    
        ReportaddText('normalised image by dividing spot image by background image', 'p', image_page);
        ReportaddImage(normalised, format = imagesFormat, image_page);         
      }
      previewCanvas.width = boxSize_X - 20;
      previewCanvas.height = boxSize_Y - 20;
      const percentage = parseFloat(percentageInput.value);
      const detectedSpotImage = processImageData(normalised, percentage);
      // data for chart
      const columnSums = calculateColumnSums(detectedSpotImage);
      const blurredData = blurArray(columnSums, parseInt(chart_blurr.value)); // Kernel size of 5
      const { startMountain, endMountain } = findMountainRange(blurredData, parseInt(kernelValleyTreshols.value), parseInt(borderTreshold.value));
      //console.log(startMountain, endMountain, blurredData.length - 1);
      const PeakMetrices = calculateMountainMetrics(blurredData, startMountain, endMountain);
      // report metrices od peak in table
      const peak_page = ReportaddPage();
      const PeakMetrices_l = PeakMetrices;
      delete PeakMetrices_l.formulas;
      ReportaddTable(PeakMetrices_l, 'Parameter', 'value', peak_page);

      PeakhtmlString = objectToHtml(PeakMetrices);
      drawLineChart(blurredData, "chartCanvas");
      drawVerticalLines('chartCanvas', startMountain, endMountain, blurredData.length-1);
      // data for chart
      previewCtx.putImageData(detectedSpotImage, 0, 0);
      const spotMetrics = calculateSum(detectedSpotImage);
      const { sum, average, pixelCount, average_color } = spotMetrics;

      current_sum = useAUC.checked ? PeakMetrices.S : sum;
      // report images
      if (includeImages.checked) {
        ReportaddText('selected spot form background:', 'p', info_page);
        ReportaddImageFromCanvas(previewCanvas, imagesFormat, info_page); 
        ReportaddText('selected spot peak on chart:', 'p', info_page);
        ReportaddImageFromCanvas(chartCanvas, imagesFormat, info_page);         
      }
      ReportaddTable(spotMetrics, 'Parameter', 'value', info_page);
      
      resultBox.innerHTML = `<h2>average spot intensity:   <span>${average}</span></h2>
      <h2>sum of pixels:   <span>${sum}</span></h2>
      <h2>spot area:   <span>${pixelCount}</span></h2>
      <h2>average pixel intensity:   <span>${average_color}</span></h2>`;
      PeakresultBox.innerHTML = PeakhtmlString;
      if (Object.keys(current_curve).length !== 0) {
        predictConcentration();
      }
    });

    function toGrayscale(imageData, rFactor, gFactor, bFactor) {
    const { width, height, data } = imageData;
    const newImageData = new ImageData(width, height);

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];     // Red channel
        const g = data[i + 1]; // Green channel
        const b = data[i + 2]; // Blue channel

        // Calculate grayscale value
        const gray = Math.round(r * rFactor + g * gFactor + b * bFactor);

        // Set grayscale value for the pixel
        newImageData.data[i] = gray;     // Red
        newImageData.data[i + 1] = gray; // Green
        newImageData.data[i + 2] = gray; // Blue
        newImageData.data[i + 3] = data[i + 3]; // Alpha remains unchanged
    }

    return newImageData;
}

function divideImageDataAndNormalize(imageData1, imageData2) {
    if (
        imageData1.width !== imageData2.width || 
        imageData1.height !== imageData2.height
    ) {
        throw new Error("ImageData objects must have the same dimensions");
    }

    const width = imageData1.width;
    const height = imageData1.height;

    // Create a new ImageData object to store the result
    const resultImageData = new ImageData(width, height);

    const data1 = imageData1.data;
    const data2 = imageData2.data;
    const resultData = resultImageData.data;

    for (let i = 0; i < data1.length; i += 4) {
        // Divide each channel (R, G, B) and normalize to 0-255
        for (let j = 0; j < 3; j++) {
            const value1 = data1[i + j];
            const value2 = data2[i + j];
            const resultValue = value2 === 0 ? 0 : (value1 / value2) * 255;
            resultData[i + j] = Math.min(Math.max(Math.round(resultValue), 0), 255);
        }

        // Copy the alpha channel without modification
        resultData[i + 3] = data1[i + 3];
    }

    return resultImageData;
}

function processImageData(imageData, percentage) {
    const data = imageData.data;
    const grayValues = [];
    let cutoffValue = percentage;

    if (!constTreshold.checked) {
        // Extract grayscale values
        for (let i = 0; i < data.length; i += 4) {
            grayValues.push(data[i]); // Red channel (same for R, G, and B in grayscale)
        }

        // Sort grayscale values to find the cutoff
        grayValues.sort((a, b) => a - b);
        const cutoffIndex = Math.floor((percentage / 100) * grayValues.length);
        cutoffValue = grayValues[cutoffIndex]; 
    }


    // Process image
    const outputData = new Uint8ClampedArray(data.length);
    for (let i = 0; i < data.length; i += 4) {
        const grayValue = data[i];
        if (grayValue >= cutoffValue) {
            // Brighter pixels: set green and blue to 0
            outputData[i] = data[i];     // Red
            outputData[i + 1] = 0;       // Green
            outputData[i + 2] = 64;       // Blue
            outputData[i + 3] = data[i + 3]; // Alpha
        } else {
            // Darker pixels remain unchanged
            outputData[i] = data[i];
            outputData[i + 1] = data[i + 1];
            outputData[i + 2] = data[i + 2];
            outputData[i + 3] = data[i + 3];
        }
    }

    return new ImageData(outputData, imageData.width, imageData.height);
}

function calculateSum(imageData) {
    const { data, width, height } = imageData; // Extract data, width, and height
    let sum = 0; // Variable to accumulate the red channel values
    let color_sum = 0;
    let pixelCount = 0; // Counter for the number of pixels meeting the criteria

    // Iterate through all pixels
    for (let i = 0; i < data.length; i += 4) {
        const red = data[i];      // Red channel
        const green = data[i + 1]; // Green channel
        const blue = data[i + 2];  // Blue channel

        // Check if green is 0 and blue is 64
        if (green !== 0 && blue !== 64) {
            sum += (255 - red); // Add red channel value to the sum
            color_sum += red;
            pixelCount++; // Increment the count of valid pixels
        }
    }
    const average_color = pixelCount > 0 ? color_sum / pixelCount : 0;
    const average = pixelCount > 0 ? sum / pixelCount : 0;
    return {sum, average, pixelCount, average_color};
}

document.getElementById('add-measurement').addEventListener('click', () => {
    const concentrationValue = parseFloat(concentrationInput.value);

    if (isNaN(concentrationValue)) {
        alert('Please enter a valid number for substance concentration.');
        return;
    }

    // Add the measurement to the array
    measurements.push([current_sum, concentrationValue]);

    // Update the table
    updateTable();
});

function updateTable() {
    const container = document.getElementById('data-container');
    container.innerHTML = ''; // Clear the existing content

    const table = document.createElement('table');

    // Create the header row
    const headerRow = document.createElement('tr');
    const headers = ['Current Average', 'Substance Concentration', 'Actions'];
    headers.forEach(headerText => {
        const th = document.createElement('th');
        th.textContent = headerText;
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Add rows from the measurements array
    measurements.forEach((measurement, index) => {
        const row = document.createElement('tr');

        // Add measurement data cells
        measurement.forEach(value => {
            const td = document.createElement('td');
            td.textContent = value;
            row.appendChild(td);
        });

        // Add the Delete button
        const actionTd = document.createElement('td');
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.onclick = () => {
            measurements.splice(index, 1); // Remove the measurement from the array
            updateTable(); // Re-render the table
        };
        actionTd.appendChild(deleteButton);
        row.appendChild(actionTd);

        table.appendChild(row);
    });

    container.appendChild(table);
}


function createConcentrationCurve() {
            // Calculate linear regression coefficients
            current_curve = linearRegression(measurements);
            displayFormula(current_curve, 'formuldBox');

        }

function predictConcentration(){
    const Ratio = parseFloat(resolutionRatio.value);
    const predicted = predictOutput(current_sum * Ratio, current_curve);
    predictionBox.textContent = `Predicted value: ${predicted}`;
}        

        function linearRegression(data) {
            const n = data.length;

            // Calculate sums
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (const [x, y] of data) {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
                sumY2 += y * y;
            }

            // Calculate slope (m) and intercept (b)
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // Calculate R² (linearity index)
            const meanY = sumY / n;
            let ssTotal = 0, ssResidual = 0;
            for (const [x, y] of data) {
                const predictedY = slope * x + intercept;
                ssTotal += (y - meanY) ** 2;
                ssResidual += (y - predictedY) ** 2;
            }
            const r2 = 1 - ssResidual / ssTotal;

            return { slpoe:slope, intercept:intercept, r2:r2 };
        }

    // Predict output using linear regression results
    function predictOutput(input, regressionResults) {
        const { slpoe: slope, intercept } = regressionResults;
        return slope * input + intercept;
    }

    function displayFormula(regressionResults, formulaDivId) {

      const formulaDiv = document.getElementById(formulaDivId);
      if (Object.keys(regressionResults).length === 0 ) {
        if (formulaDiv) {
          formulaDiv.innerHTML = `<p>No Data to Create Formula</p>`;
        } else {
          console.error(`Div with id "${formulaDivId}" not found.`);
        }
        
      }
      else{
        const { slpoe: slope, intercept, r2 } = regressionResults;
        
        // Construct the formula string
        const formula = `y = ${slope.toFixed(8)}x + ${intercept.toFixed(2)}`;
        const linearityIndex = `R² = ${r2.toFixed(8)}`;

        // Display in the specified formula div
        if (formulaDiv) {
            formulaDiv.innerHTML = `<p>Linear Regression Formula: ${formula}</p>
                                    <p>Linearity Index: ${linearityIndex}</p>
                                    <p>Input adjustment formula: x = input * ${parseFloat(resolutionRatio.value)}`;
        } else {
            console.error(`Div with id "${formulaDivId}" not found.`);
        }
      }
    }

// Function to process imageData and calculate column sums
function calculateColumnSums(imageData) {
    const { width, height, data } = imageData;
    const sums = new Array(width).fill(0);

    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const index = (y * width + x) * 4; // Calculate the pixel index
            const red = data[index];
            const green = data[index + 1];
            const blue = data[index + 2];

            if (green === 0 && blue === 64) continue;
            sums[x] += (255 - red); // Add the red channel value to the sum for this column
        }
    }
    return sums;
}


// Function to blur an array using a kernel size
function blurArray(inputArray, kernelSize) {
    const outputArray = new Array(inputArray.length).fill(0);
    const halfKernel = Math.floor(kernelSize / 2);

    for (let i = 0; i < inputArray.length; i++) {
        let sum = 0;
        let count = 0;

        for (let k = -halfKernel; k <= halfKernel; k++) {
            const idx = i + k;
            if (idx >= 0 && idx < inputArray.length) {
                sum += inputArray[idx];
                count++;
            }
        }

        outputArray[i] = sum / count;
    }
    return outputArray;
}

// Function to draw a straight-line chart on a fixed-width canvas
function drawLineChart(data, canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`Canvas with id "${canvasId}" not found.`);
        return;
    }

    const ctx = canvas.getContext("2d");
    const canvasWidth = 500; // Fixed width
    const canvasHeight = 100; // Fixed height

    // Resize canvas to fixed dimensions
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Find the maximum value for normalization
    const maxValue = Math.max(...data);
    if (maxValue === 0) return; // Prevent division by zero

    // Normalize data to fit within canvas dimensions
    const normalizedData = data.map((value) => (value / maxValue) * canvasHeight);

    // Scale data to fit the fixed width
    const step = canvasWidth / (data.length - 1);

    // Draw straight lines
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.beginPath();
    ctx.moveTo(0, canvasHeight - normalizedData[0]);

    for (let i = 1; i < data.length; i++) {
        const x = i * step;
        const y = canvasHeight - normalizedData[i];
        ctx.lineTo(x, y);
    }

    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();
}


function invertArrayValues(arr, maskZeros = false) {
    // Filter array to find min and max
    const filteredArr = maskZeros ? arr.filter(value => value !== 0) : arr;
    const min = Math.min(...filteredArr);
    const max = Math.max(...arr); // Max remains the same since we don't mask zeros for it

    // Return a new array with inverted values
    return arr.map(value => (value === 0 && maskZeros) ? 0 : max - (value - min));
}

function findMountainRange(array, maxNeighbours, threshold) {
    const midpoint = Math.floor(array.length / 2);
    let leftValleys = [];
    let rightValleys = [];

    const getNeighbours = (index, direction) => {
        let neighbours = [];
        for (let i = 1; i <= maxNeighbours; i++) {
            let neighbourIndex = index + i * direction;
            if (neighbourIndex >= 0 && neighbourIndex < array.length) {
                neighbours.push(array[neighbourIndex]);
            }
        }
        return neighbours;
    };

    // Check if there are any elements with value 0
    const hasZero = array.includes(0);

    if (hasZero) {
        // If the midpoint is 0, set range to the entire array
        if (array[midpoint] === 0) {
            return { startMountain: 0, endMountain: array.length - 1 };
        }

        // Otherwise, find the last non-zero element to the left and right of the midpoint
        let startMountain = 0;
        let endMountain = array.length - 1;

        for (let i = midpoint; i >= 0; i--) {
            if (array[i] !== 0) {
                startMountain = i;
            } else {
                break;
            }
        }

        for (let i = midpoint; i < array.length; i++) {
            if (array[i] !== 0) {
                endMountain = i;
            } else {
                break;
            }
        }

        return { startMountain, endMountain };
    }

    // No elements with value 0; continue with finding valleys
    for (let i = 0; i < array.length; i++) {
        const leftNeighbours = getNeighbours(i, -1);
        const rightNeighbours = getNeighbours(i, 1);

        const leftAvg = leftNeighbours.length
            ? leftNeighbours.reduce((a, b) => a + b, 0) / leftNeighbours.length
            : null;

        const rightAvg = rightNeighbours.length
            ? rightNeighbours.reduce((a, b) => a + b, 0) / rightNeighbours.length
            : null;

        const element = array[i];
        const avgLeft = leftAvg !== null ? leftAvg : rightAvg;
        const avgRight = rightAvg !== null ? rightAvg : leftAvg;

        if (
            avgLeft !== null &&
            avgRight !== null &&
            avgLeft > element * (1 + threshold / 100) &&
            avgRight > element * (1 + threshold / 100)
        ) {
            if (i < midpoint) {
                leftValleys.push(i);
            } else {
                rightValleys.push(i);
            }
        }
    }

    let startMountain, endMountain;

    if (leftValleys.length === 0) {
        startMountain = 0;
    } else {
        startMountain = leftValleys[leftValleys.length - 1];
    }

    if (rightValleys.length === 0) {
        endMountain = array.length - 1;
    } else {
        endMountain = rightValleys[0];
    }

    return { startMountain, endMountain };
}


function calculateMountainMetrics(array, start, end) {
    const mountain = array.slice(start, end + 1);
    const peakIndex = findPeakIndex(mountain) + start; // Adjust to original array index
    const peakHeight = array[peakIndex];

    // Calculate Mountain Properties
    const H = peakHeight - Math.min(...mountain); // Height
    const baseLevel = Math.min(...mountain);
    const Wbas = end - start;

    function calculateWidthAtHeight(heightPercent) {
        const heightThreshold = baseLevel + heightPercent * H;
        let left = start;
        let right = end;

        // Find the left boundary
        while (left <= end && array[left] < heightThreshold) {
            left++;
        }

        // Find the right boundary
        while (right >= start && array[right] < heightThreshold) {
            right--;
        }

        return right - left;
    }

    const W05 = calculateWidthAtHeight(0.5);
    const W01 = calculateWidthAtHeight(0.1);
    const W005 = calculateWidthAtHeight(0.05);

    // Calculate Area (S) using Trapezoidal Rule
    const S = mountain.reduce((area, value, index) => {
        if (index === 0) return area; // No segment before the first point
        const dx = 1; // Assuming unit spacing
        const avgHeight = (mountain[index] + mountain[index - 1]) / 2;
        return area + avgHeight * dx;
    }, 0);

    // Calculate A and B at 5% height
    const height05Threshold = baseLevel + 0.05 * H;
    const height10Threshold = baseLevel + 0.10 * H;
    const leftBoundary05 = findBoundaryAtHeight(array, start, peakIndex, height05Threshold, -1);
    const rightBoundary05 = findBoundaryAtHeight(array, peakIndex, end, height05Threshold, 1);
    const leftBoundary10 = findBoundaryAtHeight(array, start, peakIndex, height10Threshold, -1);
    const rightBoundary10 = findBoundaryAtHeight(array, peakIndex, end, height10Threshold, 1);    
    const A05 = peakIndex - leftBoundary05;
    const B05 = rightBoundary05 - peakIndex;
    const A10 = peakIndex - leftBoundary10;
    const B10 = rightBoundary10 - peakIndex;    

    // Calculate Factors
    const AsymmetryFactor = B10 / A10; // at 10% of height
    const TailingFactor = (A05 + B05) / (2 * A05); // at 5 % of height

    // Generate HTML
    const formulas = `
    <div>
        <p><strong>Asymmetry Factor (AF):</strong> AF = B / A = ${B10.toFixed(2)} / ${A10.toFixed(2)} = ${AsymmetryFactor.toFixed(2)}</p>
        <p><em>A and B are measured at 10% of the peak height.</em></p>
        <p><strong>Tailing Factor (TF):</strong> TF = (A + B) / (2 * A) = (${A05.toFixed(2)} + ${B05.toFixed(2)}) / (2 * ${A05.toFixed(2)}) = ${TailingFactor.toFixed(2)}</p>
        <p><em>A and B are measured at 5% of the peak height.</em></p>
    </div>
`;

    // Return Results
    const result = {
        H,
        Wbas,
        W05,
        W01,
        W005,
        S,
        A05,
        B05,
        A10,
        B10,        
        AsymmetryFactor,
        TailingFactor,
        formulas
    };
    return result;

    // Helper Functions
    function findPeakIndex(arr) {
        const maxVal = Math.max(...arr);
        const maxIndices = arr.map((val, idx) => (val === maxVal ? idx : -1)).filter(idx => idx !== -1);
        return Math.floor((maxIndices[0] + maxIndices[maxIndices.length - 1]) / 2); // Center of plateau if peak is flat
    }

    function findBoundaryAtHeight(array, start, end, height, direction) {
        let index = start;
        while (index !== end && array[index] >= height) {
            index += direction;
        }
        return index - direction; // Return the last valid index
    }
}

function objectToHtml(obj) {
    return Object.entries(obj)
        .map(([key, value]) => `<h2>${key}: <span>${value}</span></h2>`)
        .join('');
}

function drawVerticalLines(canvasId, startMountain, endMountain, dataLength) {
    // Get the canvas element and its context
    const canvas = document.getElementById(canvasId);
    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        console.error("Invalid canvas ID or element not found.");
        return;
    }

    const ctx = canvas.getContext("2d");
    if (!ctx) {
        console.error("Unable to get canvas context.");
        return;
    }

    // Calculate canvas positions for the lines
    const startX = (startMountain / dataLength) * canvas.width;
    const endX = (endMountain / dataLength) * canvas.width;

    // Set the line color and width
    ctx.strokeStyle = "green";
    ctx.lineWidth = 3;

    // Draw the first vertical line
    ctx.beginPath();
    ctx.moveTo(startX, 0);        // Start at the top of the canvas
    ctx.lineTo(startX, canvas.height); // End at the bottom of the canvas
    ctx.stroke();

    // Draw the second vertical line
    ctx.beginPath();
    ctx.moveTo(endX, 0);         // Start at the top of the canvas
    ctx.lineTo(endX, canvas.height); // End at the bottom of the canvas
    ctx.stroke();
}

// model management
function updateModelList() {
    modelList.innerHTML = '';
    const searchTerm = modelSearch.value.toLowerCase();
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(MODEL_PREFIX) && key.toLowerCase().includes(searchTerm)) {
            const li = document.createElement('li');
            li.textContent = key.substring(MODEL_PREFIX.length); // Display without prefix
            li.addEventListener('click', () => {
                modelNameInput.value = key.substring(MODEL_PREFIX.length);
            });
            modelList.appendChild(li);
        }
    }
}

saveButton.addEventListener('click', async () => {
    const modelName = modelNameInput.value;
    if (!modelName) {
        alert("Please enter a model name.");
        return;
    }

    const prefixedModelName = MODEL_PREFIX + modelName; // Add prefix

    if (localStorage.getItem(prefixedModelName)) {
        if (!confirm("Model with this name already exists. Do you want to overwrite it?")) {
            return;
        }
    }

    try {
        const modelData = await getSharableData();
        localStorage.setItem(prefixedModelName, JSON.stringify(modelData));
        updateModelList();
        modelNameInput.value = "";
        alert("Model saved!");
    } catch (error) {
        console.error("Error saving model:", error);
        alert("An error occurred while saving the model.");
    }
});

modelSearch.addEventListener('input', updateModelList);

window.addEventListener('storage', updateModelList);

copyAllButton.addEventListener('click', () => {
    const allModels = {};
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(MODEL_PREFIX)) {
            allModels[key.substring(MODEL_PREFIX.length)] = JSON.parse(localStorage.getItem(key)); // Save without prefix in json
        }
    }
    navigator.clipboard.writeText(JSON.stringify(allModels)).then(() => {
        alert('All models data copied to clipboard!');
    });
});

pasteAllButton.addEventListener('click', () => {
    navigator.clipboard.readText().then(text => {
        try {
            const parsedModels = JSON.parse(text);
            for (const modelName in parsedModels) {
                localStorage.setItem(MODEL_PREFIX + modelName, JSON.stringify(parsedModels[modelName])); // Save with prefix in localstorage
            }
            updateModelList();
            alert('Models data pasted from clipboard!');
        } catch (error) {
            alert('Invalid data in clipboard. Please copy valid JSON model data.');
        }
    });
});

deleteButton.addEventListener('click', () => {
    const modelToDelete = modelNameInput.value;
    if (modelToDelete && confirm(`Are you sure you want to delete model "${modelToDelete}"?`)) {
        localStorage.removeItem(MODEL_PREFIX + modelToDelete); // Remove with prefix
        updateModelList();
        modelNameInput.value = "";
    }
});


applyButton.addEventListener('click', () => { // Event listener for apply button
    const modelName = modelNameInput.value;
    if (!modelName) {
        alert("Please select a model to apply.");
        return;
    }

    const prefixedModelName = MODEL_PREFIX + modelName;
    const storedModel = localStorage.getItem(prefixedModelName);

    if (storedModel) {
        try {
            const modelData = JSON.parse(storedModel);
            setSharableData(modelData); // Call the apply function
        } catch (error) {
            console.error("Error parsing model data:", error);
            alert("Error loading model data.");
        }
    } else {
        alert("Model not found.");
    }
});

updateModelList();


// raport code:
recordButton.addEventListener('click', () => {
    isRecording = !isRecording;
    recordButton.textContent = isRecording ? 'Stop Recording Report' : 'Start Recording Report';
    document.body.style.backgroundColor = isRecording ? 'Khaki' : raportColor;
});

clearButton.addEventListener('click', () => {
    reportContent.innerHTML = '';
    reportData = [];
});

function ReportaddText(text, element, page) {
    if (isRecording) {
        let p = document.createElement(element);
        p.textContent = text;
        page.appendChild(p);
    }
}


function ReportaddImage(imageData, format, page) {
    if (isRecording) {
      const ctx = raportCanvas.getContext('2d');
      raportCanvas.width = imageData.width;
      raportCanvas.height = imageData.height;

      ctx.putImageData(imageData, 0, 0);

      let imageUrl;
      if (format.toLowerCase() === 'jpeg' || format.toLowerCase() === 'jpg') {
          imageUrl = raportCanvas.toDataURL('image/jpeg', 0.7); // Adjust quality (0-1) as needed
      } else if(format.toLowerCase() === 'png'){
          imageUrl = raportCanvas.toDataURL(`image/png`); // Use specified format (default png)
      }

      let img = document.createElement('img');
      img.src = imageUrl;
      page.appendChild(img);
    }
}

function ReportaddImageFromCanvas(canvas, format, page) {
    if (isRecording) {
      const ctx = canvas.getContext('2d');

      let imageUrl;
      if (format.toLowerCase() === 'jpeg' || format.toLowerCase() === 'jpg') {
          imageUrl = canvas.toDataURL('image/jpeg', 0.7); // Adjust quality (0-1) as needed
      } else if(format.toLowerCase() === 'png'){
          imageUrl = canvas.toDataURL(`image/png`); // Use specified format (default png)
      }

      let img = document.createElement('img');
      img.src = imageUrl;
      page.appendChild(img);
    }
}

function ReportaddTable(data, column_1_header, column_2_header, page) {
    if (isRecording) {
        let table = document.createElement('table');
        let headerRow = table.insertRow();

        const th1 = document.createElement('th');
        th1.textContent = column_1_header;
        headerRow.appendChild(th1);

        const th2 = document.createElement('th');
        th2.textContent = column_2_header;
        headerRow.appendChild(th2);

        // Use Object.entries to get key-value pairs
        for (const [key, value] of Object.entries(data)) {
          let row = table.insertRow(); // Create a single row
            let td1 = document.createElement('td');
            td1.textContent = key; // Display the value
            row.appendChild(td1);
            let td2 = document.createElement('td');
            td2.textContent = value; // Display the value
            row.appendChild(td2);
        }

        page.appendChild(table);
    }
}

async function generatePDF(mode) {
  try {
    document.body.style.zoom = "100%";
    const pdf = await mergeAllDivsToPDF();

    if (mode === 'save') {
      pdf.save(`${RaportName.value || 'Report'}.pdf`);
      return true;
    } else if (mode === 'share') {
      const pdfBytes = pdf.output('arraybuffer');
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const fileName = RaportName.value.length > 0 ? `${RaportName.value}.report.pdf` : 'Report.pdf';
      const file = new File([blob], fileName, { type: 'application/pdf' });

      if (navigator.share) {
        try {
          await navigator.share({
            title: RaportName.value.length > 0 ? `${RaportName.value} Report` : 'QTLC Report',
            files: [file],
          });
          console.log('Shared successfully');
          return true;
        } catch (error) {
          console.error('Error sharing:', error);
          return false;
        }
      } else {
        alert('Web Share API is not supported in this browser.');
        return false;
      }
    }
  } catch (error) {
    console.error("Error generating PDF:", error);
    return false;
  }
}


async function mergeAllDivsToPDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
  });

  const pageHeight = pdf.internal.pageSize.getHeight();
  const pageWidth = pdf.internal.pageSize.getWidth();

  // Get the container element
  if (!reportContent) {
    console.error("Page container element not found!");
    throw new Error("Page container element not found!");
  }

  // Get all direct child elements with the class 'page'
  const pages = Array.from(reportContent.querySelectorAll(":scope > .page"));

  for (const [index, page] of pages.entries()) {
    // Adjust the style of the current page

    await pdf.html(page, {
      x: 0,
      y: pageHeight * index,
      width: pageWidth, // Ensure it fits within the page
      windowWidth: page.scrollWidth, // Optional: Scale content to fit
    });

    if (index < pages.length - 1) {
      pdf.addPage("a4", "p");
    }
  }

  // Return the generated PDF
  return pdf;
}

function ReportaddPage(){
  if (isRecording) {
        let page = document.createElement('div');
        let hr = document.createElement('hr');
        page.classList.add("page");
        reportContent.appendChild(page);

        reportContent.appendChild(hr);
        return page;
    }
}

let previousText = savePdfButton.textContent;
let previousColor = savePdfButton.style.backgroundColor;

savePdfButton.addEventListener('click', async () => {
  savePdfButton.textContent = '(preparing report)';
  savePdfButton.style.backgroundColor = 'blue';
  const status = await generatePDF('save');
  savePdfButton.textContent = status ? '(report success)' : '(report failed)';
  savePdfButton.style.backgroundColor = status ? 'green' : 'red';
  // wait 0.5 s
  await new Promise(resolve => setTimeout(resolve, 500));
  savePdfButton.textContent = previousText;  // Reverting to default text
  savePdfButton.style.backgroundColor = previousColor;  // Reverting to default color
});

shareButton.addEventListener('click', async () => {
  let previousTextShare = shareButton.textContent;
  let previousColorShare = shareButton.style.backgroundColor;
  
  shareButton.textContent = '(preparing report)';
  shareButton.style.backgroundColor = 'blue';
  await generatePDF('share');
  savePdfButton.textContent = status ? '(report success)' : '(report failed)';
  savePdfButton.style.backgroundColor = status ? 'green' : 'red';
  // wait 0.5 s
  await new Promise(resolve => setTimeout(resolve, 500));
  shareButton.textContent = previousTextShare;
  shareButton.style.backgroundColor = previousColorShare;
});


</script>

</body>
</html>