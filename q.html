<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Quantity TLC Image Processor - A scientific web app for analyzing and processing Thin Layer Chromatography (TLC) images with precision and efficiency.">
  <meta name="keywords" content="TLC image processing, Thin Layer Chromatography, scientific web app, image analysis, chromatography tools, web-based TLC analysis, no installation TLC software, client-side image analysis, smartphone TLC processor, UV chamber analysis, TLC plate analysis, lightweight TLC app, first online TLC tool, serverless chromatography, portable TLC image processor, TLC for mobile devices, instant TLC quantification, web app for TLC quantification, TLC analysis anywhere, innovative TLC tools, online chromatography software">
  <meta name="authors" content="Damian Bezara">
  <meta name="version" content="4.1.0">
  <meta name="robots" content="index, follow">
  <title>Quantity TLC Image Processor</title>
  <style>
 /* General Body Styling */
body {
  font-family: 'Roboto', Arial, sans-serif;
  padding: 0;
  margin: 0;
  background-color: #ccd4e3;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  color: #333;
  line-height: 1;
}

br {
    line-height: 0; /* Removes extra spacing */
    margin: 0;      /* Ensures no margin is added */
    display: block; /* Ensures it still acts as a block-level element */
  }

  #modelListContainer {  /* Container for the list */
    max-height: 20vh; /* Maximum height of the container (20% of viewport height) */
    border: 1px solid #ccc;
    overflow-y: auto; /* Enable vertical scrolling */
    padding: 0.5rem;
    margin-bottom: 1rem;
    width: 80%;
}

ul {
    list-style-type: none;
    padding: 0;
    margin: 0; /* Reset default ul margins */
}

li {
    cursor: pointer;
    padding: 0.5rem;
    border-bottom: 1px solid #eee;
    transition: background-color 0.2s ease; /* Smooth hover transition */
}

li:hover {
    background-color: #f5f5f5; /* Slightly lighter background on hover */
}

li:last-child { /*Remove border from last element*/
    border-bottom: none;
}

/* Input Fields */
input {
  margin: 0.4em 0;
  padding: 0.2em;
  font-size: 1.5em;
  border: 1px solid blueviolet;
  background-color: #d4c8d8;
  border-radius: 4px;
  width: 100%;
  max-width: 400px;
  text-align: center;
}

/* Textarea Styling */
textarea {
  margin: 0.4em 0;
  padding: 0.2em;
  font-size: 1.5em;
  border: 1px solid blueviolet;
  background-color: #d4c8d8;
  border-radius: 4px;
  width: 100%;
  max-width: 400px;
  text-align: left;
  resize: vertical; /* Allow vertical resizing */
  height: 100px; /* Default height */
}

/* Canvas Elements */
#loadingCanvasContainer {
  display: none;
}

#raportCanvas{
  display: none;
}

#background-canvas, #data-canvas{
  max-width: 100%;
  height: auto;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  border: 1px solid #ff0080;
  border-radius: 5px;
  background-color: #fff;
}

.preview-canvas {
  display: block;
  margin-top: 1em;
  border: 1px solid #007BFF;
  border-radius: 5px;
  background-color: #fff;
  width: 100%;
  max-width: 500px;
  height: auto;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Buttons */
button {
  padding: 0.3em 0.7em;
  font-size: 1.5em;
  font-weight: bold;
  cursor: pointer;
  background-color: #007BFF;
  color: white;
  border: none;
  border-radius: 5px;
  margin: 0.5em auto;
  transition: background-color 0.3s ease;
  display: block;
  text-align: center;
}

button:hover {
  background-color: #0056b3;
}

/* Data Container */
#data-container {
  width: 100%;
  max-width: 800px;
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  border: 1px solid #ccc;
  border-radius: 5px;
  background-color: #fff;
  margin: 0.6em 0;
  padding: 0.4em;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Table Styling */
table {
  width: 100%;
  border-collapse: collapse;
  box-sizing: border-box;
}

th, td {
  border: 1px solid #ddd;
  padding: 10px;
  text-align: center;
  font-size: 1.2em;
}

th {
  background-color: #f4f4f4;
  font-weight: bold;
}

tr:nth-child(even) {
  background-color: #f9f9f9;
}

tr:hover {
  background-color: #f1f1f1;
}

/* Labels and Text */
label {
  font-weight: bold;
  margin-bottom: 0.2em;
  display: block;
  font-size: 1.2em;
}

p {
  margin: 0.4em 0;
  font-size: 1.2em;
  color: #555;
}

span {
  font-weight: bold;
  color: #26173d;
  font-size: 1.1em;
  text-align: left;
}

strong {
  font-weight: bold;
  color: #000000;
  font-size: 1.2em;
  text-align: left;
}

em {
  font-style: italic;
  color: #26173d;
  font-size: 0.7em;
  margin-left: 0.5em;
  display: block;
  text-align: center;
}

/* Headings */
h1, h2 {
  margin: 0.2em 0;
  text-align: center;
  font-weight: bold;
  color: #007BFF;
}

h1 {
  font-size: 2em;
}

h2 {
  font-size: 1.8em;
}

h2 {
  font-size: 1.6em;
  color: #26173d;
}

.slider {
    width: 95%;
    margin: 0.2em 0;
  }

  input[type="checkbox"] {
    height: 1em;
    width: 1em;
  }

  .section_border {
      border: 0.2em solid #3f3a3a;
      border-radius: 5px;
      background-color: #ffffff;
      margin: 10px 0;
      padding: 10px;
      box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
      width: 90%;
    }

    .section_border h3 {
      margin: 0;
      font-size: 1.2em;
      color: #ffffff;
      background-color: #3f3a3a;
      padding: 10px;
      border-radius: 3px;
      cursor: pointer;
      text-align: center;
    }

    .section {
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
    }
</style>
<style id="preview">
.pdf {
    padding: 0;
    margin: 0;
    width: 100%;
    background-color: white;


    font-size: 1.5vh;
    line-height: 1;
    box-sizing: border-box;
    border: none;
}


.pdf h1, 
.pdf h2, 
.pdf h3 {
    margin: 0;
    font-weight: bold;
    text-align: center;
    background-color: white;
    color: black;
}

.pdf h1 {
    font-size: 3vh;
    margin: 0;
}

.pdf h2 {
    font-size: 2.5vh;
    margin: 0;
}

.pdf h3 {
    font-size: 2vh;
    margin: 0;
}

.pdf p {
    margin: 0;
    text-align: justify;
}

.pdf span {
    margin: 0;
    word-wrap: break-word; /* Ensures long words break and wrap */
    overflow-wrap: anywhere; /* Breaks words at any point if necessary */
    white-space: normal; /* Allows text to wrap onto the next line */
    display: inline-block; /* Allows the span to behave like a block for wrapping */
    max-width: 100%; /* Limits the width to prevent horizontal scrolling */       
}

.pdf strong {
  font-weight: bold;
  color: #000000;
  font-size: 1.6vh;
  text-align: left;
}

.pdf img {
    width: 32%; /* Scale images to fit the container */
    height: auto;
    margin: 0 0 0 0;
    display: inline-block;
}

.pdf table {
    width: 95%;
    border-collapse: collapse;
    margin: 0 0 0 0;
    font-size: 1.5vh;
}

.pdf th, 
.pdf td {
    border: 1px solid #ccc;
    padding: 0;
    text-align: center;
}

.pdf th {
    background-color: #f4f4f4;
    font-weight: bold;
}

.pdf tr:nth-child(even) {
    background-color: #f9f9f9;
}

.pdf tr:hover {
    background-color: #eaeaea;
}

div.page{
    margin: 0;
    width: 100%;
    box-sizing: border-box; /* Include padding in width/height */
    padding: 1% 1% 1% 1%;
}

  </style>
</head>
<body>

  <h1>Mobile Image Processor</h1>

  <!-- File Inputs -->
   <div class="section_border">
    <h3 onclick="toggleVisibility('s_inputs', 'section_border_title', 'auto')" name="Input Panel" id="section_border_title">(hide) Input Panel</h3>
    <div class="section" id="s_inputs">
      <label for="rotateRight90">Rotate images right by 90 deg.</label>
      <input type="checkbox" id="rotateRight90">
      <label for="flipHorizontally">Flip images horizontally</label>
      <input type="checkbox" id="flipHorizontally">
      <label for="data-file">Upload Data Image:</label>
      <input type="file" id="data-file" accept="image/*" multiple>
      <label for="background-file">Upload Background Image:</label>
      <input type="file" id="background-file" accept="image/*" multiple>
      <button id="reloadImages">Reload</button>
      <label for="percentageInput">Percent of darkest pixels to detect spot:</label>
      <input type="number" id="percentageInput" value="15" min="0" max="255">
      <label for="constTreshold">Use constant treshold instead percental</label>
      <input type="checkbox" id="constTreshold">
      <label for="showLoaded">Show Loaded Images</label>
      <input type="checkbox" id="showLoaded">
    </div>
</div>

  <!-- Slider -->
  <div class="section_border">
    <h3 onclick="toggleVisibility('slider_container', 'slider_container_title', 'auto')" name="Slider Panel" id="slider_container_title">(hide) Slider Panel</h3>
    <div id="slider_container" class="section">
      <label for="slider_X">Box Size X: <span id="slider-value_X">50</span></label>
      <input type="range" id="slider_X" min="30" max="150" value="50" class="slider"><br>
      <label for="slider_Y">Box Size Y: <span id="slider-value_Y">50</span></label>
      <input type="range" id="slider_Y" min="30" max="150" value="50" class="slider"><br>      
      <label for="slider_L">Shift left: <span id="slider-value_L">0</span></label>
      <input type="range" id="slider_L" min="-50" max="50" value="0" class="slider"><br>   
      <label for="slider_T">Shift top: <span id="slider-value_T">0</span></label>
      <input type="range" id="slider_T" min="-50" max="50" value="0" class="slider">
      <label for="chart_blurr">Chart Blurr kernel size</label>
      <input type="number" id="chart_blurr" min="1" max="10" value="5">     
      <label for="borderTreshold">Treshold for valley detection in %</label>
      <input type="number" id="borderTreshold" min="0" max="5" value="1">    
      <label for="kernelValleyTreshols">Kernel for valley detection in pixels</label>
      <input type="number" id="kernelValleyTreshols" min="1" max="5" value="3">
      <label for="track_analysis">analyse whole track instead of single peak</label>
      <input type="checkbox" id="track_analysis">          
    </div>
</div>


  <!-- Processing site -->
  <button id="process-button">Process</button>
  <h2 id="predictionBox">Predicted value: </h2>
  <label for="measurmentComment">Measurement name or comment</label>
  <input type="text" id="measurmentComment">   


  <!-- Hidden Canvases -->
   <div id="loadingCanvasContainer">
    <p>Image with track / spot</p>
    <canvas id="data-canvas"></canvas>
    <p>Image with background</p>
    <canvas id="background-canvas"></canvas>
  </div>

  <!-- Preview Canvas -->
  <div class="section_border">
    <h3 onclick="toggleVisibility('outcome_container', 'outcome_container_title', 'auto')" name="Result Panel" id="outcome_container_title">(hide) Result Panel</h3>
    <div id="outcome_container" class="section">
      <canvas id="preview-canvas" class="preview-canvas"></canvas>
      <canvas id="raw-canvas" class="preview-canvas" style="display: none;"></canvas>
      <canvas id="chartCanvas" class="preview-canvas"></canvas>
      <div class="section_border">
        <div id="resultBox" class="section">Spot Parameters not ready yet</div>
      </div>
      <div class="section_border">
        <h3 onclick="toggleVisibility('PeakresultBox', 'PeakresultBox_title', 'auto')" name="Peak Panel" id="PeakresultBox_title">(hide) Peak Panel</h3>
        <div id="PeakresultBox" class="section">Peak Parameters not ready yet</div>
      </div>
  </div>
</div>

<div class="section_border">
  <h3 onclick="toggleVisibility('curve_container', 'curve_container_title', 'auto')" name="Curve Panel" id="curve_container_title">(hide) Curve Panel</h3> 
  <div id="curve_container" class="section">
    <label for="useAUC">Use AUC instead of total spot pixels sum</label>
    <input type="checkbox" id="useAUC">    
    <label for="substance-concentration">Substance Concentration:</label>
    <input type="number" id="substance-concentration">
    <div id="buttonContainer">
      <button id="add-measurement">Add Measurement</button>
      <button onclick="createConcentrationCurve()">Create Concentration Curve</button>
      <button onclick="predictConcentration()">Predict Concentration</button>
    </div>
    <div id="formuldBox">Formula not ready yet</div><br>
    <div id="data-container"></div>
  </div>
</div>

<div class="section_border">
  <h3 onclick="toggleVisibility('model_container', 'model_container_title', 'auto')" name="Model Panel" id="model_container_title">(hide) Model Panel</h3> 
  <div id="model_container" class="section">  
    <label for="resolutionRatio">ratio to adjust to blueprint model</label>
    <input type="number" id="resolutionRatio" value="1">
    <button id="sharableData_paste">Paste model data</button>
    <button id="sharableData_copy">Copy model data</button>
    <label for="substanceName">Substance name</label>
    <input type="text" id="substanceName">
    <label for="modelName">Model Name:</label>
    <input type="text" id="modelName">    
    <label for="modelComment">model description</label>
    <textarea id="modelComment"></textarea>
<!-- color inputs /--> 
<label for="redFactor">Red channel multiplyer</label>
<input type="number" id="redFactor" min="0" max="1" value="0.2126" step="0.0001">     
<label for="greenFactor">Green channel multiplyer</label>
<input type="number" id="greenFactor" min="0" max="1" value="0.7152" step="0.0001">    
<label for="blueFactor">Blue channel multiplyer</label>
<input type="number" id="blueFactor" min="0" max="1" value="0.0722" step="0.0001">    
<!-- moddels panel -->
<button id="saveModel">Save Model</button>
<input type="text" id="modelSearch" placeholder="Search models...">
<div id="modelListContainer">
  <ul id="modelList"></ul>
</div>
<button id="copyAllModels">Copy All Models</button>
<button id="pasteAllModels">Paste All Models</button>
    <button id="deleteModel">Delete Model</button>
    <button id="applyModel">Apply Model</button>
  </div>
</div>
<!-- report section -->
<div class="section_border">
  <h3 onclick="toggleVisibility('raport_container', 'raport_container_title', 'auto')" name="Raport Panel" id="raport_container_title">(hide) Raport Panel</h3> 
  <div id="raport_container" class="section">
    <label for="RaportName">Raport file name</label>
    <input type="text" id="RaportName"> 
    <button id="recordButton">Start Recording Report</button>
    <button id="clearButton">Clear Report</button>
    <button id="savePdfButton">Save as html</button>
    <button id="shareButton">Share as html</button>
    <label for="ReportfileInput">load report html</label>
    <input type="file" id="ReportfileInput" accept=".html" onchange="loadHtmlToReportContent()">


    <!-- report params section -->
    <div class="section_border">
      <h3 onclick="toggleVisibility('ReportSettings_container', 'ReportSettings_container_title', 'auto')" name="Report Settings Panel" id="ReportSettings_container_title">(hide) Report Settings Panel</h3>
      <div id="ReportSettings_container" class="section">
        <label for="includeImages">Include visual images (e.g., graphs, charts) in the PDF report</label>
        <input type="checkbox" id="includeImages"> 
        <label for="useLossless">Select lossless PNG format for high-quality images in the PDF</label>
        <span>(If unchecked: jpg with 70% quality is used)</span>
        <input type="checkbox" id="useLossless"> 
        <label for="includeParams">Include chromatographic parameters and data for qualitative analysis</label>
        <input type="checkbox" id="includeParams"> 
        <label for="includeExplanations">Include explanations and interpretations generated by the program</label>
        <input type="checkbox" id="includeExplanations">
        <label for="includeMetadata">Include metadata such as date, time, author, and version information</label>
        <input type="checkbox" id="includeMetadata">
        <label for="includeSummary">Add a summary section to the report</label>
        <input type="checkbox" id="includeSummary">
        <label for="MergeImportedReports">When loading new report add it to previous</label>
        <input type="checkbox" id="MergeImportedReports">         
      </div>
    </div>

    <div id="report-content" class="pdf"></div>
    <canvas id="raportCanvas"></canvas>
  </div>
</div>

<!-- other scripts -->

<!-- other scripts -->

  <script>
    // inputs
    const dataInput = document.getElementById('data-file');
    const backgroundInput = document.getElementById('background-file');
    const rotateRight90 = document.getElementById('rotateRight90');
    const flipHorizontally = document.getElementById('flipHorizontally');
    const loadingCanvasContainer = document.getElementById('loadingCanvasContainer');
    // sliders
    const slider_X = document.getElementById('slider_X');
    const sliderValue_X = document.getElementById('slider-value_X');
    const slider_Y = document.getElementById('slider_Y');
    const sliderValue_Y = document.getElementById('slider-value_Y');    
    const slider_L = document.getElementById('slider_L');
    const sliderValue_L = document.getElementById('slider-value_L');
    const slider_T = document.getElementById('slider_T');
    const sliderValue_T = document.getElementById('slider-value_T');
    const track_analysis = document.getElementById('track_analysis');    
    // process
    const processButton = document.getElementById('process-button');
    const dataCanvas = document.getElementById('data-canvas');
    const dataCtx = dataCanvas.getContext('2d');
    const backgroundCanvas = document.getElementById('background-canvas');
    const bcgCtx = backgroundCanvas.getContext('2d');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d'); 
    const rawCanvas = document.getElementById('raw-canvas');
    const rawCtx = rawCanvas.getContext('2d'); 
    const percentageInput = document.getElementById("percentageInput");
    const constTreshold = document.getElementById('constTreshold');
    const borderTreshold  = document.getElementById('borderTreshold');
    const kernelValleyTreshols = document.getElementById('kernelValleyTreshols');
    const resultBox = document.getElementById("resultBox");
    const PeakresultBox = document.getElementById("PeakresultBox");
    const useAUC = document.getElementById("useAUC");
    const concentrationInput = document.getElementById('substance-concentration');
    const predictionBox = document.getElementById('predictionBox');
    const sharableData_paste= document.getElementById('sharableData_paste');
    const sharableData_copy = document.getElementById('sharableData_copy');
    const resolutionRatio = document.getElementById('resolutionRatio');
    const modelComment = document.getElementById('modelComment');
    const substanceName = document.getElementById('substanceName');
    const chart_blurr = document.getElementById('chart_blurr');
    const reloadImages = document.getElementById('reloadImages');
    const showLoaded = document.getElementById('showLoaded');
    const chartCanvas = document.getElementById('chartCanvas');
    // containers
    const model_container = document.getElementById('model_container');
    const curve_container = document.getElementById('curve_container');
    const outcome_container = document.getElementById('outcome_container');
    const slider_container = document.getElementById('slider_container');
    const s_inputs = document.getElementById('s_inputs');
    const redFactor = document.getElementById('redFactor');
    const greenFactor = document.getElementById('greenFactor');
    const blueFactor = document.getElementById('blueFactor');
    // models management:
    const modelNameInput = document.getElementById('modelName');
    const saveButton = document.getElementById('saveModel');
    const modelList = document.getElementById('modelList');
    const modelSearch = document.getElementById('modelSearch');
    const copyAllButton = document.getElementById('copyAllModels');
    const pasteAllButton = document.getElementById('pasteAllModels');
    const deleteButton = document.getElementById('deleteModel');
    const applyButton = document.getElementById('applyModel'); // Get the new button
    const MODEL_PREFIX = 'model_'; // Prefix for model keys
    // raport management
    let isRecording = false;
    const raportColor = '#ccd4e3';
    let reportContent = document.getElementById('report-content');
    const recordButton = document.getElementById('recordButton');
    const clearButton = document.getElementById('clearButton');
    const savePdfButton = document.getElementById('savePdfButton');
    const shareButton = document.getElementById('shareButton'); 
    const RaportName = document.getElementById('RaportName'); 
    const raportCanvas = document.getElementById('raportCanvas'); 
    const measurmentComment = document.getElementById('measurmentComment');
    const ReportfileInput = document.getElementById('ReportfileInput');
    // report settings
    const ReportSettings_container = document.getElementById('ReportSettings_container');
    const includeImages = document.getElementById('includeImages');
    const useLossless = document.getElementById('useLossless');
    const includeParams = document.getElementById('includeParams');
    const includeExplanations = document.getElementById('includeExplanations');
    const includeMetadata = document.getElementById('includeMetadata');
    const includeSummary = document.getElementById('includeSummary');
    const MergeImportedReports = document.getElementById('MergeImportedReports');

    let current_sum = 0;
    const measurements = []; // 2D array for storing data
    current_curve = {}; // object to store linear reggression formula

    sharableData_paste.addEventListener("click",  () => {setSharableData(true)});
    sharableData_copy.addEventListener("click",  getSharableData);

    function toggleVisibility(ID, tittle_ID, mode) {
      const section = document.getElementById(ID);
      const tittle = document.getElementById(tittle_ID);
      if (mode == 'auto') {
        if (section.style.display === "none") {
        section.style.display = "flex"; // Show the element
        tittle.textContent = `(hide) ${tittle.getAttribute("name")}`
      } else {
        section.style.display = "none"; // Hide the element
        tittle.textContent = `(show) ${tittle.getAttribute("name")}`
      }
      } else {
        if (mode == 'flex') {
          section.style.display = "flex"; // Show the element
          tittle.textContent = `(hide) ${tittle.getAttribute("name")}`          
        }
        if (mode == 'none') {
          section.style.display = "none"; // Hide the element
          tittle.textContent = `(show) ${tittle.getAttribute("name")}`         
        }
      }
    }


    // Update sliders value display
    slider_X.addEventListener('input', () => {
      sliderValue_X.textContent = slider_X.value;
    });
    slider_Y.addEventListener('input', () => {
      sliderValue_Y.textContent = slider_Y.value;
    });    
    slider_L.addEventListener('input', () => {
      sliderValue_L.textContent = slider_L.value;
    });
    slider_T.addEventListener('input', () => {
      sliderValue_T.textContent = slider_T.value;
    });    

    // Update slider value display
    async function setSharableData(clipboard){
      try {
        let data = undefined;
        if (clipboard === true) {
          const clipboardText = await navigator.clipboard.readText();
          data = JSON.parse(clipboardText);
        }
        else{
          data = JSON.parse(clipboard);
        }

      current_curve = data.current_curve;
      resolutionRatio.value = data.resolutionRatio;
      modelComment.value = data.modelComment;
      substanceName.value = data.substanceName;
      percentageInput.value = data.percentageInput;
      constTreshold.checked = data.constTreshold;
      slider_X.value = data.slider_X;
      sliderValue_X.textContent = slider_X.value;
      slider_Y.value = data.slider_Y;
      sliderValue_Y.textContent = slider_Y.value;      
      slider_L.value = data.slider_L;
      sliderValue_L.textContent = slider_L.value;
      slider_T.value = data.slider_T;
      sliderValue_T.textContent = slider_T.value;
      chart_blurr.value = data.chart_blurr;
      rotateRight90.checked = data.rotateRight90;
      flipHorizontally.checked = data.flipHorizontally;
      borderTreshold.value = data.borderTreshold;
      kernelValleyTreshols.value = data.kernelValleyTreshols;
      useAUC.checked = data.useAUC;
      showLoaded.checked = data.showLoaded;
      redFactor.value = data.redFactor;
      greenFactor.value = data.greenFactor;
      blueFactor.value = data.blueFactor;
      RaportName.value = data.RaportName;
      measurmentComment.value = data.measurmentComment;
      includeImages.checked = data.includeImages;
      useLossless.checked = data.useLossless;
      includeParams.checked = data.includeParams;
      includeExplanations.checked = data.includeExplanations;
      includeMetadata.checked = data.includeMetadata;
      includeSummary.checked = data.includeSummary;
      track_analysis.checked = data.track_analysis;
      displayFormula(current_curve, 'formuldBox');
      toggleVisibility('model_container', 'model_container_title', data.model_container);
      toggleVisibility('curve_container', 'curve_container_title', data.curve_container);
      toggleVisibility('outcome_container', 'outcome_container_title', data.outcome_container);
      toggleVisibility('slider_container', 'slider_container_title', data.slider_container);
      toggleVisibility('s_inputs', 'section_border_title', data.s_inputs);
      toggleVisibility('PeakresultBox', 'PeakresultBox_title', data.PeakresultBox);
      toggleVisibility('raport_container', 'raport_container_title', data.raport_container);
      toggleVisibility('ReportSettings_container', 'ReportSettings_container_title', data.ReportSettings_container);
      }
      catch(error){
        console.error('Error pasting from clipboard:', error);
        alert('Failed to paste from clipboard');
      }
    }

    async function getSharableData(clipboard = false) {
      try {
      const data = {
        current_curve : current_curve,
        resolutionRatio : resolutionRatio.value,
        modelComment : modelComment.value,
        substanceName : substanceName.value,
        percentageInput : percentageInput.value,
        constTreshold : constTreshold.checked,
        slider_X : slider_X.value,
        slider_Y : slider_Y.value,
        slider_L : slider_L.value,
        slider_T : slider_T.value,
        model_container : model_container.style.display,
        curve_container : curve_container.style.display,
        outcome_container : outcome_container.style.display,
        slider_container : slider_container.style.display,
        s_inputs : s_inputs.style.display,
        PeakresultBox: PeakresultBox.style.display,
        raport_container: raport_container.style.display,
        ReportSettings_container: ReportSettings_container.style.display,
        chart_blurr: chart_blurr.value,
        rotateRight90: rotateRight90.checked, 
        flipHorizontally: flipHorizontally.checked,
        borderTreshold: borderTreshold.value,
        kernelValleyTreshols: kernelValleyTreshols.value,
        useAUC: useAUC.checked,
        showLoaded : showLoaded.checked,
        redFactor : redFactor.value,
        greenFactor : greenFactor.value,
        blueFactor : blueFactor.value,
        RaportName : RaportName.value,
        measurmentComment: measurmentComment.value,
        includeImages: includeImages.checked,
        useLossless: useLossless.checked,
        includeParams: includeParams.checked,
        includeExplanations: includeExplanations.checked,
        includeMetadata: includeMetadata.checked,
        includeSummary: includeSummary.checked,
        track_analysis: track_analysis.checked
      }
      const textData = JSON.stringify(data);
      if (clipboard) {
        await navigator.clipboard.writeText(textData);
      }
      return textData;
    }
    catch (error) {
      console.error('Error copying to clipboard:', error);
      alert('Failed to copy to clipboard');
    }
  }

    function loadImageToCanvas(input, canvas, rotateRight90, flipHorizontally) {
  input.style.color = "black";
  const files = input.files;
  if (!files || files.length === 0) return;

  const ctx = canvas.getContext('2d');

  if (files.length === 1) {
    // Handle single image case
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        let width = img.width;
        let height = img.height;

        // Adjust canvas size for rotation if needed
        if (rotateRight90) {
          canvas.width = height;
          canvas.height = width;
          ctx.translate(height, 0); // Move the origin to the top-right corner
          ctx.rotate(Math.PI / 2); // Rotate 90 degrees clockwise
        } else {
          canvas.width = width;
          canvas.height = height;
        }

        if (flipHorizontally) {
          ctx.scale(-1, 1); // Flip horizontally
          ctx.translate(-width, 0); // Adjust the origin back
        }

        // Draw the image to the canvas
        ctx.drawImage(img, 0, 0);
        input.style.color = "green";
      };

      img.src = reader.result;
    };
    reader.readAsDataURL(files[0]);
    return;
  }

let combinedImageData = null;
let combinedFloatData = null;
let processedImages = 0;

Array.from(files).forEach((file, index) => {
  const reader = new FileReader();

  reader.onload = () => {
    const img = new Image();

    img.onload = () => {
      let width = img.width;
      let height = img.height;

      if (index === 0) {
        // Adjust canvas size for rotation if needed
        if (rotateRight90) {
          canvas.width = height;
          canvas.height = width;
          ctx.translate(height, 0); // Move the origin to the top-right corner
          ctx.rotate(Math.PI / 2); // Rotate 90 degrees clockwise
        } else {
          canvas.width = width;
          canvas.height = height;
        }

        if (flipHorizontally) {
          ctx.scale(-1, 1); // Flip horizontally
          ctx.translate(-width, 0); // Adjust the origin back
        }
      } else if (canvas.width !== (rotateRight90 ? height : width) || canvas.height !== (rotateRight90 ? width : height)) {
        console.error("All images must have the same dimensions.");
        input.style.color = "red";
        return;
      }

      // Draw the current image to the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      // Get the image data of the current image
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Initialize combinedFloatData and combinedImageData if it's the first image
      if (!combinedFloatData) {
        combinedFloatData = new Float32Array(imageData.data.length);
        for (let i = 0; i < combinedFloatData.length; i++) {
          combinedFloatData[i] = 0;
        }
        combinedImageData = ctx.createImageData(canvas.width, canvas.height);
      }

      // Add the current image's data to combinedFloatData, excluding the alpha channel
      for (let i = 0; i < imageData.data.length; i += 4) {
        combinedFloatData[i] += imageData.data[i];       // Red
        combinedFloatData[i + 1] += imageData.data[i + 1]; // Green
        combinedFloatData[i + 2] += imageData.data[i + 2]; // Blue
        combinedFloatData[i + 3] = 255;                  // Alpha remains opaque
      }

      processedImages++;

      // If all images are processed, calculate the average and update the canvas
      if (processedImages === files.length) {
        for (let i = 0; i < combinedFloatData.length; i += 4) {
          combinedImageData.data[i] = combinedFloatData[i] / files.length;       // Red
          combinedImageData.data[i + 1] = combinedFloatData[i + 1] / files.length; // Green
          combinedImageData.data[i + 2] = combinedFloatData[i + 2] / files.length; // Blue
          combinedImageData.data[i + 3] = 255;                                    // Alpha
        }

        ctx.putImageData(combinedImageData, 0, 0);
        input.style.color = "green";
      }
    };

    img.src = reader.result;
  };

  reader.readAsDataURL(file);
});

}


    dataInput.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    backgroundInput.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));
    flipHorizontally.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    rotateRight90.addEventListener('change', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));

    flipHorizontally.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));
    rotateRight90.addEventListener('change', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));    
    reloadImages.addEventListener('click', () => loadImageToCanvas(dataInput, dataCanvas, rotateRight90.checked, flipHorizontally.checked));
    reloadImages.addEventListener('click', () => loadImageToCanvas(backgroundInput, backgroundCanvas, rotateRight90.checked, flipHorizontally.checked));

    showLoaded.addEventListener('change', () => {
    if (showLoaded.checked) {
      loadingCanvasContainer.style.display = 'block'; // Show the canvas container
    } else {
      loadingCanvasContainer.style.display = 'none'; // Hide the canvas container
    }
});

    // Process button action
    processButton.addEventListener('click', async () => {
      if (track_analysis.checked) {
        await whole_track_analysis();
        //await peak_analysis();
      }
      else{
        await peak_analysis();
      }
    });

  function analyzeArrayWithKernel(array, kernelSize, height) {
    const mountains = [];
    let status = "constant"; // Possible values: "constant", "ascending", "descending"
    let mountainStart = null;
    let mountainEnd = null;

    for (let i = 0; i < array.length; i++) {
        // Get neighbors to the right based on kernel size
        const neighbors = [];
        for (let k = 1; k <= kernelSize; k++) {
            if (i + k < array.length) {
                neighbors.push(array[i + k]);
            }
        }

        // Calculate the average of neighbors
        const average = neighbors.length > 0 
            ? neighbors.reduce((sum, val) => sum + val, 0) / neighbors.length
            : 0;

        // Determine the new status based on comparison with average
        let newStatus;
        if (array[i] > average) {
            newStatus = "descending";
        } else if (array[i] < average) {
            newStatus = "ascending";
        } else {
            newStatus = "constant";
        }

        // Handle status change logic
        if (newStatus !== status) {
            if ((status === "constant" || status === "descending") && newStatus === "ascending" ) {
              if (mountainStart !== null) {
                mountainEnd = i;
                mountains.push({ start: mountainStart, end: mountainEnd });
                mountainStart = i;
                mountainEnd = null;                
              }
              else{
                mountainStart = mountainStart === null ? i : mountainStart;
              }
                
            } 
            else if (status === "descending" && mountainStart !== null && (newStatus === "constant" )) {
                mountainEnd = i;
                mountains.push({ start: mountainStart, end: mountainEnd });
                mountainStart = null;
                mountainEnd = null;
            }          

            // Update status
            //console.log(status, newStatus);
            status = newStatus;
            
        }
    }
    // Find the global minimum and maximum values in arr
    const globalMin = Math.min(...array);
    const globalMax = Math.max(...array);
    const globalDistance = globalMax - globalMin;
    // Validate and extract real mountains
    const realMountains = mountains.filter(({ start, end }) => {
      const fragment = array.slice(start, end + 1); // Get the fragment of arr
      const fragmentMin = Math.min(...fragment);
      const fragmentMax = Math.max(...fragment);
      const fragmentDistance = fragmentMax - fragmentMin;

      // Compare fragment distance to x% of global distance
      return fragmentDistance >= (height / 100) * globalDistance;
    });
    return realMountains;
}

function findMaxIndex(array, startIndex, endIndex) {
    // Validate indices
    if (startIndex < 0 || endIndex >= array.length || startIndex > endIndex) {
        throw new Error("Invalid start or end index.");
    }

    // Find the maximum value in the range
    let maxValue = -Infinity;
    for (let i = startIndex; i <= endIndex; i++) {
        if (array[i] > maxValue) {
            maxValue = array[i];
        }
    }

    // Collect all indices with the maximum value
    const maxIndices = [];
    for (let i = startIndex; i <= endIndex; i++) {
        if (array[i] === maxValue) {
            maxIndices.push(i);
        }
    }

    // Return the index in the middle of the max indices
    const middleIndex = Math.floor(maxIndices.length / 2);
    return maxIndices[middleIndex];
}

async function whole_track_analysis(){ // analysierrr
  // make info report page
  const measureKEY = generateUniqueUrl('c');
  const imagesFormat = useLossless.checked ? 'png' : 'jpeg';
  const info_page = ReportaddPage(measureKEY, 'info');
  ReportaddText('New measurement type: "spot only analysis" was attempted', 'h3', info_page);
  if (measurmentComment.value.length > 0) {
    ReportaddText(`'${measurmentComment.value}'` , 'p', info_page);
  } 

  const boxSize_X = parseInt(slider_X.value, 10);
  const boxSize_Y = parseInt(slider_Y.value, 10);
  const boxShiftLeft = parseInt(slider_L.value);
  const boxShiftTop = parseInt(slider_T.value);
  const dataWidth = dataCanvas.width;
  const dataHeight = dataCanvas.height;

  const r = parseFloat(redFactor.value);
  const g = parseFloat(blueFactor.value);
  const b = parseFloat(blueFactor.value);

  if (dataWidth === 0 || dataHeight === 0) {
    alert('Please upload a data image first.');
    return;
  }

  // Calculate the box dimensions
  const boxHalf_X = Math.floor(boxSize_X / 2);
  const boxHalf_Y = Math.floor(boxSize_Y / 2);
  const centerX = Math.floor(dataWidth / 2);
  const centerY = Math.floor(dataHeight / 2);
  const startX = centerX - boxHalf_X - boxShiftLeft;
  const startY = centerY - boxHalf_Y - boxShiftTop;

  // Draw the box to the preview canvas
  previewCanvas.width = boxSize_X;
  previewCanvas.height = boxSize_Y;

  // get image data prepared to normalzation
  const imageData = dataCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);
  // vvv create previed data
  previewCtx.putImageData(imageData, 0, 0);
  rawCanvas.width = boxSize_X - 20;
  rawCanvas.height = boxSize_Y - 20;
  const rawPreview = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);
  rawCtx.putImageData(rawPreview, 0, 0);
  // ^^^ create preview data
  const grayData = toGrayscale(imageData, r, g, b);
  previewCtx.putImageData(grayData, 0, 0);
  previewCtx.filter = 'blur(2px)'; // Set blur amount (e.g., 5px)
  previewCtx.drawImage(previewCanvas, 0, 0);   
  previewCtx.filter = 'none';
  const readyData = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);

  // get image data prepared to normalzation
  const bcgData = bcgCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);      
  const grayBcg = toGrayscale(bcgData, r, g, b);
  previewCtx.putImageData(grayBcg, 0, 0);
  previewCtx.filter = 'blur(5px)'; // Set blur amount (e.g., 5px)
  previewCtx.drawImage(previewCanvas, 0, 0);   
  previewCtx.filter = 'none';
  const readyBcg = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);
  const normalised = divideImageDataAndNormalize(readyData, readyBcg);  

  previewCanvas.width = boxSize_X - 20;
  previewCanvas.height = boxSize_Y - 20;
  const percentage = parseFloat(percentageInput.value);
  const detectedSpotImage = processImageData(normalised, percentage);  

  // data for chart
  const columnSums = calculateColumnSums(detectedSpotImage);
  const blurredData = blurArray(columnSums, parseInt(chart_blurr.value)); // Kernel size of 5
  //const peaks = findPeaks(blurredData);
  const mountains = analyzeArrayWithKernel(blurredData, parseInt(kernelValleyTreshols.value), parseInt(borderTreshold.value));
  let distances = [];
  let peakParams = [];
  let interPeakParams = [];
  let starts = [];
  let ends = [];
  //console.log(mountains.length, mountains);
  previewCtx.putImageData(detectedSpotImage, 0, 0);
  drawLineChart(blurredData, "chartCanvas");

  mountains.forEach( (mountain) => { 
    peak = findMaxIndex(blurredData, mountain.start, mountain.end);
    const startMountain  = mountain.start;
    const endMountain = mountain.end;
    drawVerticalLines('chartCanvas', startMountain, endMountain, blurredData.length-1);
    const PeakMetrices = calculateMountainMetrics(blurredData, startMountain, endMountain);
    //PeakhtmlString = objectToHtml(PeakMetrices);
    // data for chart
    distances.push(endMountain - startMountain);
    starts.push(startMountain);
    ends.push(endMountain);
    const Rfactor = peak / blurredData.length;
    const Kfactor = (1 - Rfactor) / Rfactor;
    PeakMetrices.RF = Rfactor; // peak is index of blurredData
    PeakMetrices.k = Kfactor; // retention factor
    PeakMetrices.RM = Math.log10(Kfactor); // RM factor
    PeakMetrices.HobsBAS = PeakMetrices.Wbas / 16 / Rfactor, // Hobs at basis
    PeakMetrices.Hobs05 = PeakMetrices.W05 / 16 / Rfactor, // Hobs at basis at 50% of height
    PeakMetrices.NobsBAS = 16 * Rfactor / PeakMetrices.Wbas, // nr of theoretical shelves at base of peak
    PeakMetrices.Nobs05 = 16 * Rfactor / PeakMetrices.W05 // nr of theoretical shelves at 50% of peak
    peakParams.push(PeakMetrices);
  });
  for (let i = 0; i < mountains.length - 1; i++) {
    const mountain1 = mountains[i];
    const mountain2 = mountains[i+1];
    const peak1 = findMaxIndex(blurredData, mountain1.start, mountain1.end);
    const peak2 = findMaxIndex(blurredData, mountain2.start, mountain2.end);

    width2 = (ends[i+1] - starts[i+1]) / blurredData.length;
    width1 = (ends[i] - starts[i]) / blurredData.length;
    const Rfactor1 = peak1 / blurredData.length;
    const Rfactor2 = peak2 / blurredData.length;
    const RSz = (Rfactor2 - Rfactor1) / 0.5 / (width2 + width1);
    k2 = (1 - Rfactor2) / Rfactor2;
    k1 = (1 - Rfactor1) / Rfactor1;
    const selectivity = 0.25 * ( k2 / k1 - 1);
    const RFavg = (Rfactor1 + Rfactor2) / 2;
    const efficacyBAS = RFavg * peakParams[i].NobsBAS;
    const efficacy05 = RFavg * peakParams[i].Nobs05;
    const retention = 1 - RFavg;
    const RSssrBAS = selectivity * retention * efficacyBAS;
    const RSssr05 = selectivity * retention * efficacy05;
    interPeakParams.push({
      RSz: RSz,
      RSssrBAS: RSssrBAS,
      RSssr05: RSssr05
    });
  }
  let PeakhtmlString = '<h2>Peaks analysis</h2>';
  for (let i = 0; i < peakParams.length; i++) {
    const element = peakParams[i];
    //const raw_element = structuredClone(element);
    //delete raw_element.formulas;
    HTMLfragment = objectToHtml(element); // for now formulas explanation for all peaks
    PeakhtmlString += `<h3>peak: ${i + 1}</h3>`; // header nr of peak
    PeakhtmlString += HTMLfragment;
    PeakhtmlString += '<hr>';
  }
  let InterPeakhtmlString = '<h2>Inter-Peaks analysis</h2>';
  for (let i = 0; i < interPeakParams.length; i++) {
    const element = interPeakParams[i];
    //const raw_element = structuredClone(element);
    //delete raw_element.formulas;
    HTMLfragment = objectToHtml(element); // for now formulas explanation for all peaks
    InterPeakhtmlString += `<h3>Inter-peak: ${i + 1}</h3>`; // header nr of peak
    InterPeakhtmlString += HTMLfragment;
    InterPeakhtmlString += '<hr>';
  }  
  const previewHTML = PeakhtmlString + InterPeakhtmlString;
  PeakresultBox.innerHTML = previewHTML;
  // report metrices od peak in table
      // raport image:
      if (includeImages.checked) {
      const image_page = ReportaddPage(measureKEY, 'image');
      ReportaddText('spot cutted image:', 'p', image_page);
      ReportaddImage(imageData, imagesFormat, image_page);
      ReportaddText('spot cutted image - grayscale:', 'p', image_page);
      ReportaddImage(grayData, imagesFormat, image_page);
      ReportaddText('spot cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
      ReportaddImage(readyData, imagesFormat, image_page);          
      ReportaddText('background cutted image:', 'p', image_page);
      ReportaddImage(bcgData, format = imagesFormat, image_page);
      ReportaddText('background cutted image - grayscale:', 'p', image_page);
      ReportaddImage(grayBcg, format = imagesFormat, image_page);
      ReportaddText('background cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
      ReportaddImage(readyBcg, format = imagesFormat, image_page);    
      ReportaddText('normalised image by dividing spot image by background image', 'p', image_page);
      ReportaddImage(normalised, format = imagesFormat, image_page);
      // info page
      ReportaddText('selected track form background:', 'p', info_page);
      ReportaddImageFromCanvas(previewCanvas, imagesFormat, info_page); 
      ReportaddText('selected track peaks on chart:', 'p', info_page);
      ReportaddImageFromCanvas(chartCanvas, imagesFormat, info_page);   
      ReportaddText('selected raw track:', 'p', info_page);
      ReportaddImageFromCanvas(rawCanvas, imagesFormat, info_page); 
    }
  if (includeParams.checked) {
    const peak_page = ReportaddPage(measureKEY, 'peak');
    ReportaddHTMLFromString(previewHTML , 'div', peak_page);        
  }
  if (includeMetadata.checked) {
    const currentModel = await getSharableData();
    const localMeta = ReportaddPage(measureKEY, 'measuremeta');
    ReportaddText(`Model data in JSON used for current track analysis:` , 'p', localMeta);
    ReportaddText(currentModel , 'span', localMeta);
  }
  if (includeExplanations.checked) {
    const explanations = ReportaddPage(measureKEY, 'explanations');
    otherMetricessReport(explanations);
  }
}


function SimplefindMountainRange(array, index, maxNeighbours, threshold) {
    let leftValleys = [];
    let rightValleys = [];

    const getNeighbours = (index, direction) => {
        let neighbours = [];
        for (let i = 1; i <= maxNeighbours; i++) {
            let neighbourIndex = index + i * direction;
            if (neighbourIndex >= 0 && neighbourIndex < array.length) {
                neighbours.push(array[neighbourIndex]);
            }
        }
        return neighbours;
    };

    // Check if there are any elements with value 0
    const hasZero = array.includes(0);

    if (hasZero) {
        // If the specified index is 0, set range to the entire array
        if (array[index] === 0) {
            return { startMountain: 0, endMountain: array.length - 1 };
        }

        // Otherwise, find the last non-zero element to the left and right of the index
        let startMountain = 0;
        let endMountain = array.length - 1;

        for (let i = index; i >= 0; i--) {
            if (array[i] !== 0) {
                startMountain = i;
            } else {
                break;
            }
        }

        for (let i = index; i < array.length; i++) {
            if (array[i] !== 0) {
                endMountain = i;
            } else {
                break;
            }
        }

        return { startMountain, endMountain };
    }

    // No elements with value 0; continue with finding valleys
    for (let i = 0; i < array.length; i++) {
        const leftNeighbours = getNeighbours(i, -1);
        const rightNeighbours = getNeighbours(i, 1);

        const leftAvg = leftNeighbours.length
            ? leftNeighbours.reduce((a, b) => a + b, 0) / leftNeighbours.length
            : null;

        const rightAvg = rightNeighbours.length
            ? rightNeighbours.reduce((a, b) => a + b, 0) / rightNeighbours.length
            : null;

        const element = array[i];
        const avgLeft = leftAvg !== null ? leftAvg : rightAvg;
        const avgRight = rightAvg !== null ? rightAvg : leftAvg;

        if (
            avgLeft !== null &&
            avgRight !== null &&
            avgLeft > element * (1 + threshold / 100) &&
            avgRight > element * (1 + threshold / 100)
        ) {
            if (i < index) {
                leftValleys.push(i);
            } else {
                rightValleys.push(i);
            }
        }
    }

    let startMountain, endMountain;

    if (leftValleys.length === 0) {
        startMountain = 0;
    } else {
        startMountain = leftValleys[leftValleys.length - 1];
    }

    if (rightValleys.length === 0) {
        endMountain = array.length - 1;
    } else {
        endMountain = rightValleys[0];
    }

    return { startMountain, endMountain };
}

function findPeaks(arr) {
    const peaks = [];
    for (let i = 1; i < arr.length - 1; i++) {
        if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
            peaks.push(i);
        }
    }
    return peaks;
}

  // Update sliders when track_analysis is toggled
  track_analysis.addEventListener('change', () => {
    const updateSlider = (slider, minValue, maxValue, valueDisplay) => {
      slider.min = minValue;
      slider.max = maxValue;
      // Ensure slider value is within the new range
      slider.value = Math.max(minValue, Math.min(slider.value, maxValue));
      valueDisplay.textContent = slider.value;
    };

    if (track_analysis.checked) {
      const maxH = Math.round(dataCanvas.height * 0.1);
      const SmaxH = maxH > 30 ? maxH : dataCanvas.height;
      const maxW = Math.round(dataCanvas.width * 0.5);
      const SmaxW = maxW > 30 ? maxW : dataCanvas.width;
      updateSlider(slider_X, 30, dataCanvas.width, sliderValue_X);
      updateSlider(slider_Y, 30, SmaxH, sliderValue_Y);
      updateSlider(slider_L, -Math.round(SmaxW / 2), Math.round(SmaxW / 2), sliderValue_L);
      updateSlider(slider_T, -Math.round(SmaxH / 2), Math.round(SmaxH / 2), sliderValue_T);
      rawCanvas.style.display = 'block';
    } else {
      updateSlider(slider_X, 0, 150, sliderValue_X);
      updateSlider(slider_Y, 0, 150, sliderValue_Y);
      updateSlider(slider_L, -50, 50, sliderValue_L);
      updateSlider(slider_T, -50, 50, sliderValue_T);
      rawCanvas.style.display = 'none';
    }
  });

 async function peak_analysis(){ // analysierrr
    // make info report page
    const measureKEY = generateUniqueUrl('c');
    const imagesFormat = useLossless.checked ? 'png' : 'jpeg';
    const info_page = ReportaddPage(measureKEY, 'info');
    ReportaddText('New measurement type: "whole track analysis" was attempted', 'h3', info_page);
    if (measurmentComment.value.length > 0) {
      ReportaddText(`'${measurmentComment.value}'` , 'p', info_page);
    } 
  
    const boxSize_X = parseInt(slider_X.value, 10);
    const boxSize_Y = parseInt(slider_Y.value, 10);
    const boxShiftLeft = parseInt(slider_L.value);
    const boxShiftTop = parseInt(slider_T.value);
    const dataWidth = dataCanvas.width;
    const dataHeight = dataCanvas.height;

    const r = parseFloat(redFactor.value);
    const g = parseFloat(blueFactor.value);
    const b = parseFloat(blueFactor.value);

    if (dataWidth === 0 || dataHeight === 0) {
      alert('Please upload a data image first.');
      return;
    }

    // Calculate the box dimensions
    const boxHalf_X = Math.floor(boxSize_X / 2);
    const boxHalf_Y = Math.floor(boxSize_Y / 2);
    const centerX = Math.floor(dataWidth / 2);
    const centerY = Math.floor(dataHeight / 2);
    const startX = centerX - boxHalf_X - boxShiftLeft;
    const startY = centerY - boxHalf_Y - boxShiftTop;

    // Draw the box to the preview canvas
    previewCanvas.width = boxSize_X;
    previewCanvas.height = boxSize_Y;
    // get image data prepared to normalzation
    const imageData = dataCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);
    const grayData = toGrayscale(imageData, r, g, b);
    previewCtx.putImageData(grayData, 0, 0);
    previewCtx.filter = 'blur(2px)'; // Set blur amount (e.g., 5px)
    previewCtx.drawImage(previewCanvas, 0, 0);   
    previewCtx.filter = 'none';
    const readyData = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);

    // get image data prepared to normalzation
    const bcgData = bcgCtx.getImageData(startX, startY, boxSize_X, boxSize_Y);      
    const grayBcg = toGrayscale(bcgData, r, g, b);
    previewCtx.putImageData(grayBcg, 0, 0);
    previewCtx.filter = 'blur(5px)'; // Set blur amount (e.g., 5px)
    previewCtx.drawImage(previewCanvas, 0, 0);   
    previewCtx.filter = 'none';
    const readyBcg = previewCtx.getImageData(10, 10, boxSize_X-20, boxSize_Y-20);
    const normalised = divideImageDataAndNormalize(readyData, readyBcg);
    // raport image:
    if (includeImages.checked) {
      const image_page = ReportaddPage(measureKEY, 'image');
      ReportaddText('spot cutted image:', 'p', image_page);
      ReportaddImage(imageData, imagesFormat, image_page);
      ReportaddText('spot cutted image - grayscale:', 'p', image_page);
      ReportaddImage(grayData, imagesFormat, image_page);
      ReportaddText('spot cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
      ReportaddImage(readyData, imagesFormat, image_page);          
      ReportaddText('background cutted image:', 'p', image_page);
      ReportaddImage(bcgData, format = imagesFormat, image_page);
      ReportaddText('background cutted image - grayscale:', 'p', image_page);
      ReportaddImage(grayBcg, format = imagesFormat, image_page);
      ReportaddText('background cutted image - grayscale & blurred - cutted edges:', 'p', image_page);
      ReportaddImage(readyBcg, format = imagesFormat, image_page);    
      ReportaddText('normalised image by dividing spot image by background image', 'p', image_page);
      ReportaddImage(normalised, format = imagesFormat, image_page);         
    }
    previewCanvas.width = boxSize_X - 20;
    previewCanvas.height = boxSize_Y - 20;
    const percentage = parseFloat(percentageInput.value);
    const detectedSpotImage = processImageData(normalised, percentage);
    // data for chart
    const columnSums = calculateColumnSums(detectedSpotImage);
    const blurredData = blurArray(columnSums, parseInt(chart_blurr.value)); // Kernel size of 5
    //const { startMountain, endMountain } = findMountainRange(blurredData, parseInt(kernelValleyTreshols.value), parseInt(borderTreshold.value));
   const mountains = analyzeArrayWithKernel(blurredData, parseInt(kernelValleyTreshols.value), parseInt(borderTreshold.value));
    const midpoint = Math.round((blurredData.length - 1) / 2);
    const ranges = [];
    //console.log(mountains);
    mountains.forEach((mountain)=>{
      if(mountain.start <= midpoint && mountain.end >= midpoint){
        ranges.push(mountain);
      }
    });
    //console.log(ranges);
    const mountain = ranges.length > 0 ? ranges[0] : {start: 0 , end: blurredData.length - 1};
    const startMountain  = mountain.start;
    const endMountain = mountain.end;
    //console.log(startMountain, endMountain);

    //console.log(startMountain, endMountain, blurredData.length - 1);
    const PeakMetrices = calculateMountainMetrics(blurredData, startMountain, endMountain);
    // report metrices od peak in table
    if (includeParams.checked) {
      const peak_page = ReportaddPage(measureKEY, 'peak');
      const PeakMetrices_l = structuredClone(PeakMetrices);
      delete PeakMetrices_l.formulas;
      ReportaddTable(PeakMetrices_l, 'Parameter', 'value', peak_page);        
    }


    const PeakhtmlString = objectToHtml(PeakMetrices);
    drawLineChart(blurredData, "chartCanvas");
    drawVerticalLines('chartCanvas', startMountain, endMountain, blurredData.length-1);
    // data for chart
    previewCtx.putImageData(detectedSpotImage, 0, 0);
    const spotMetrics = calculateSum(detectedSpotImage);
    const { sum, average, pixelCount, average_color } = spotMetrics;

    current_sum = useAUC.checked ? PeakMetrices.S : sum;
    // report images
    if (includeImages.checked) {
      ReportaddText('selected spot form background:', 'p', info_page);
      ReportaddImageFromCanvas(previewCanvas, imagesFormat, info_page); 
      ReportaddText('selected spot peak on chart:', 'p', info_page);
      ReportaddImageFromCanvas(chartCanvas, imagesFormat, info_page);         
    }
    if (includeParams.checked) {
      ReportaddTable(spotMetrics, 'Parameter', 'value', info_page);
    }
    if (includeExplanations.checked) {
      const explanations = ReportaddPage(measureKEY, 'explanations');
      ReportaddText('Formulas used to count params', 'h3', explanations);
      ReportaddHTMLFromString(PeakMetrices.formulas, 'div', explanations);
      otherMetricessReport(explanations);
    }
    
    
    resultBox.innerHTML = `<h2>average spot intensity:   <span>${average}</span></h2>
    <h2>sum of pixels:   <span>${sum}</span></h2>
    <h2>spot area:   <span>${pixelCount}</span></h2>
    <h2>average pixel intensity:   <span>${average_color}</span></h2>`;
    PeakresultBox.innerHTML = PeakhtmlString;
    if (Object.keys(current_curve).length !== 0) {
      predictConcentration();
      ReportaddText(`${predictionBox.textContent}` , 'p', info_page);
      ReportaddText(`Resolution Ratio: ${resolutionRatio.value}` , 'p', info_page);
    }
    if (includeMetadata.checked) {
      const currentModel = await getSharableData();
      const localMeta = ReportaddPage(measureKEY, 'measuremeta');
      ReportaddText(`Model data in JSON used for current prediction:` , 'p', localMeta);
      ReportaddText(currentModel , 'span', localMeta);
    }
      
  }

  function otherMetricessReport(page){
    ReportaddText('Other measurement params:', 'h3', page);
      const imageProcessingOptions = `
        <table>
          <tr>
            <th>Parameter Name</th>
            <th>Description</th>
            <th>Used Value</th>
          </tr>
          <tr>
            <td>rotate_right_90</td>
            <td>Rotate both data and background images by 90 degrees in the right direction</td>
            <td>${rotateRight90.checked}</td>
          </tr>
          <tr>
            <td>flip_horizontally</td>
            <td>Flip both data and background images horizontally</td>
            <td>${flipHorizontally.checked}</td>
          </tr>
          <tr>
            <td>data_file</td>
            <td>Number of photos loaded to data input</td>
            <td>${dataInput.files.length}</td>
          </tr>
          <tr>
            <td>background_file</td>
            <td>Number of photos loaded to background input</td>
            <td>${backgroundInput.files.length }</td>
          </tr>
          <tr>
            <td>constant_treshold</td>
            <td>When checked - use constant pixel value from 'spot detection treshold' as treshold to detect spot instead of percent of darkest pixels</td>
            <td>${constTreshold.checked}</td>
          </tr>
          <tr>
            <td>spot_detection_treshold</td>
            <td>Value to be used as treshold to detect spots</td>
            <td>${percentageInput.value}</td>
          </tr>
          <tr>
            <td>slider_X</td>
            <td>Horizontal size of spot analysis area in px</td>
            <td>${slider_X.value}</td>
          </tr>
          <tr>
            <td>slider_Y</td>
            <td>Vertical size of spot analysis area in px</td>
            <td>${slider_Y.value}</td>
          </tr>
          <tr>
            <td>slider_L</td>
            <td>Horizontal shift of spot analysis area in px</td>
            <td>${slider_L.value}</td>
          </tr>
          <tr>
            <td>slider_T</td>
            <td>Vertical shift of spot analysis area in px</td>
            <td>${slider_T.value}</td>
          </tr>
          <tr>
            <td>chart_blurr</td>
            <td>Kernel size to blur chart data before further processing</td>
            <td>${chart_blurr.value}</td>
          </tr>
          <tr>
            <td>border_treshold</td>
            <td>Minimal difference between measurement pixel row and neighbors to detect valley</td>
            <td>${borderTreshold.value}</td>
          </tr>
          <tr>
            <td>kernel_valley_treshols</td>
            <td>Size of neighbor pixel rows - kernel for valley detection</td>
            <td>${kernelValleyTreshols.value}</td>
          </tr>
          <tr>
            <td>use_AUC</td>
            <td>If true AUC of one spot is used for concentration prediction, else whole spot conglomeration area</td>
            <td>${useAUC.checked}</td>
          </tr>
          <tr>
            <td>red_Factor</td>
            <td>Red channel multiplier</td>
            <td>${redFactor.value}</td>
          </tr>
          <tr>
            <td>green_Factor</td>
            <td>Green channel multiplier</td>
            <td>${greenFactor.value}</td>
          </tr>
          <tr>
            <td>blue_Factor</td>
            <td>Blue channel multiplier</td>
            <td>${blueFactor.value}</td>
          </tr>
        </table>        
      `
      ReportaddHTMLFromString(imageProcessingOptions, 'div', page);
  }

    function toGrayscale(imageData, rFactor, gFactor, bFactor) {
    const { width, height, data } = imageData;
    const newImageData = new ImageData(width, height);

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];     // Red channel
        const g = data[i + 1]; // Green channel
        const b = data[i + 2]; // Blue channel

        // Calculate grayscale value
        const gray = Math.round(r * rFactor + g * gFactor + b * bFactor);

        // Set grayscale value for the pixel
        newImageData.data[i] = gray;     // Red
        newImageData.data[i + 1] = gray; // Green
        newImageData.data[i + 2] = gray; // Blue
        newImageData.data[i + 3] = data[i + 3]; // Alpha remains unchanged
    }

    return newImageData;
}

function divideImageDataAndNormalize(imageData1, imageData2) {
    if (
        imageData1.width !== imageData2.width || 
        imageData1.height !== imageData2.height
    ) {
        throw new Error("ImageData objects must have the same dimensions");
    }

    const width = imageData1.width;
    const height = imageData1.height;

    // Create a new ImageData object to store the result
    const resultImageData = new ImageData(width, height);

    const data1 = imageData1.data;
    const data2 = imageData2.data;
    const resultData = resultImageData.data;

    for (let i = 0; i < data1.length; i += 4) {
        // Divide each channel (R, G, B) and normalize to 0-255
        for (let j = 0; j < 3; j++) {
            const value1 = data1[i + j];
            const value2 = data2[i + j];
            const resultValue = value2 === 0 ? 0 : (value1 / value2) * 255;
            resultData[i + j] = Math.min(Math.max(Math.round(resultValue), 0), 255);
        }

        // Copy the alpha channel without modification
        resultData[i + 3] = data1[i + 3];
    }

    return resultImageData;
}

function processImageData(imageData, percentage) {
    const data = imageData.data;
    const grayValues = [];
    let cutoffValue = percentage;

    if (!constTreshold.checked) {
        // Extract grayscale values
        for (let i = 0; i < data.length; i += 4) {
            grayValues.push(data[i]); // Red channel (same for R, G, and B in grayscale)
        }

        // Sort grayscale values to find the cutoff
        grayValues.sort((a, b) => a - b);
        const cutoffIndex = Math.floor((percentage / 100) * grayValues.length);
        cutoffValue = grayValues[cutoffIndex]; 
    }


    // Process image
    const outputData = new Uint8ClampedArray(data.length);
    for (let i = 0; i < data.length; i += 4) {
        const grayValue = data[i];
        if (grayValue >= cutoffValue) {
            // Brighter pixels: set green and blue to 0
            outputData[i] = data[i];     // Red
            outputData[i + 1] = 0;       // Green
            outputData[i + 2] = 64;       // Blue
            outputData[i + 3] = data[i + 3]; // Alpha
        } else {
            // Darker pixels remain unchanged
            outputData[i] = data[i];
            outputData[i + 1] = data[i + 1];
            outputData[i + 2] = data[i + 2];
            outputData[i + 3] = data[i + 3];
        }
    }

    return new ImageData(outputData, imageData.width, imageData.height);
}

function calculateSum(imageData) {
    const { data, width, height } = imageData; // Extract data, width, and height
    let sum = 0; // Variable to accumulate the red channel values
    let color_sum = 0;
    let pixelCount = 0; // Counter for the number of pixels meeting the criteria

    // Iterate through all pixels
    for (let i = 0; i < data.length; i += 4) {
        const red = data[i];      // Red channel
        const green = data[i + 1]; // Green channel
        const blue = data[i + 2];  // Blue channel

        // Check if green is 0 and blue is 64
        if (green !== 0 && blue !== 64) {
            sum += (255 - red); // Add red channel value to the sum
            color_sum += red;
            pixelCount++; // Increment the count of valid pixels
        }
    }
    const average_color = pixelCount > 0 ? color_sum / pixelCount : 0;
    const average = pixelCount > 0 ? sum / pixelCount : 0;
    return {sum, average, pixelCount, average_color};
}

document.getElementById('add-measurement').addEventListener('click', () => {
    const concentrationValue = parseFloat(concentrationInput.value);

    if (isNaN(concentrationValue)) {
        alert('Please enter a valid number for substance concentration.');
        return;
    }

    // Add the measurement to the array
    measurements.push([current_sum, concentrationValue]);

    // Update the table
    updateTable();
});

function updateTable() {
    const container = document.getElementById('data-container');
    container.innerHTML = ''; // Clear the existing content

    const table = document.createElement('table');

    // Create the header row
    const headerRow = document.createElement('tr');
    const headers = ['Current Average', 'Substance Concentration', 'Actions'];
    headers.forEach(headerText => {
        const th = document.createElement('th');
        th.textContent = headerText;
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Add rows from the measurements array
    measurements.forEach((measurement, index) => {
        const row = document.createElement('tr');

        // Add measurement data cells
        measurement.forEach(value => {
            const td = document.createElement('td');
            td.textContent = value;
            row.appendChild(td);
        });

        // Add the Delete button
        const actionTd = document.createElement('td');
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.onclick = () => {
            measurements.splice(index, 1); // Remove the measurement from the array
            updateTable(); // Re-render the table
        };
        actionTd.appendChild(deleteButton);
        row.appendChild(actionTd);

        table.appendChild(row);
    });

    container.appendChild(table);
}


function createConcentrationCurve() {
    // Calculate linear regression coefficients
    current_curve = linearRegression(measurements);
    displayFormula(current_curve, 'formuldBox');
    const concentration = ReportaddPage(generateUniqueUrl('c'), 'curve');
    ReportaddText('Concentration curve creation was attempted' , 'h3', concentration);
    const formula = document.getElementById('formuldBox').innerHTML;
    ReportaddText('Formula was created:' , 'strong', concentration);
    ReportaddHTMLFromString(formula, 'div', concentration);
    if (includeParams.checked) {
      const curve_data = document.getElementById('data-container').innerHTML;
      ReportaddText('Data used for formula creation:' , 'strong', concentration);
      const curve_table = remove_nr_Column(curve_data, 2);
      ReportaddHTMLFromString(curve_table, 'div', concentration);
    }
  }

  function remove_nr_Column(htmlString, nr) {
    // Parse the HTML string into a DOM structure
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlString, 'text/html');
    
    // Find the table
    const table = doc.querySelector('table');
    if (!table) {
        console.error('No table found in the HTML string.');
        return htmlString; // Return original HTML if no table is found
    }

    // Loop through all rows in the table
    const rows = table.querySelectorAll('tr');
    rows.forEach(row => {
        const cells = row.querySelectorAll('th, td');
        cells[nr].remove();
    });

    // Serialize the updated DOM back to an HTML string
    return doc.body.innerHTML;
}

function predictConcentration(){
    const Ratio = parseFloat(resolutionRatio.value);
    const predicted = predictOutput(current_sum * Ratio, current_curve);
    predictionBox.textContent = `Predicted value: ${predicted}`;
}        

        function linearRegression(data) {
            const n = data.length;

            // Calculate sums
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (const [x, y] of data) {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
                sumY2 += y * y;
            }

            // Calculate slope (m) and intercept (b)
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            // Calculate R (linearity index)
            const meanY = sumY / n;
            let ssTotal = 0, ssResidual = 0;
            for (const [x, y] of data) {
                const predictedY = slope * x + intercept;
                ssTotal += (y - meanY) ** 2;
                ssResidual += (y - predictedY) ** 2;
            }
            const r2 = 1 - ssResidual / ssTotal;

            return { slpoe:slope, intercept:intercept, r2:r2 };
        }

    // Predict output using linear regression results
    function predictOutput(input, regressionResults) {
        const { slpoe: slope, intercept } = regressionResults;
        return slope * input + intercept;
    }

    function displayFormula(regressionResults, formulaDivId) {

      const formulaDiv = document.getElementById(formulaDivId);
      if (Object.keys(regressionResults).length === 0 ) {
        if (formulaDiv) {
          formulaDiv.innerHTML = `<p>No Data to Create Formula</p>`;
        } else {
          console.error(`Div with id "${formulaDivId}" not found.`);
        }
        
      }
      else{
        const { slpoe: slope, intercept, r2 } = regressionResults;
        
        // Construct the formula string
        const formula = `y = ${slope.toFixed(8)}x + ${intercept.toFixed(2)}`;
        const linearityIndex = `R = ${r2.toFixed(8)}`;

        // Display in the specified formula div
        if (formulaDiv) {
            formulaDiv.innerHTML = `<p>Linear Regression Formula: ${formula}</p>
                                    <p>Linearity Index: ${linearityIndex}</p>
                                    <p>Input adjustment formula: x = input * ${parseFloat(resolutionRatio.value)}`;
        } else {
            console.error(`Div with id "${formulaDivId}" not found.`);
        }
      }
    }

// Function to process imageData and calculate column sums
function calculateColumnSums(imageData) {
    const { width, height, data } = imageData;
    const sums = new Array(width).fill(0);

    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            const index = (y * width + x) * 4; // Calculate the pixel index
            const red = data[index];
            const green = data[index + 1];
            const blue = data[index + 2];

            if (green === 0 && blue === 64) continue;
            sums[x] += (255 - red); // Add the red channel value to the sum for this column
        }
    }
    return sums;
}


// Function to blur an array using a kernel size
function blurArray(inputArray, kernelSize) {
    const outputArray = new Array(inputArray.length).fill(0);
    const halfKernel = Math.floor(kernelSize / 2);

    for (let i = 0; i < inputArray.length; i++) {
        let sum = 0;
        let count = 0;

        for (let k = -halfKernel; k <= halfKernel; k++) {
            const idx = i + k;
            if (idx >= 0 && idx < inputArray.length) {
                sum += inputArray[idx];
                count++;
            }
        }

        outputArray[i] = sum / count;
    }
    return outputArray;
}

// Function to draw a straight-line chart on a fixed-width canvas
function drawLineChart(data, canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`Canvas with id "${canvasId}" not found.`);
        return;
    }

    const ctx = canvas.getContext("2d");
    const canvasWidth = 500; // Fixed width
    const canvasHeight = 100; // Fixed height

    // Resize canvas to fixed dimensions
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Find the maximum value for normalization
    const maxValue = Math.max(...data);
    if (maxValue === 0) return; // Prevent division by zero

    // Normalize data to fit within canvas dimensions
    const normalizedData = data.map((value) => (value / maxValue) * canvasHeight);

    // Scale data to fit the fixed width
    const step = canvasWidth / (data.length - 1);

    // Draw straight lines
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.beginPath();
    ctx.moveTo(0, canvasHeight - normalizedData[0]);

    for (let i = 1; i < data.length; i++) {
        const x = i * step;
        const y = canvasHeight - normalizedData[i];
        ctx.lineTo(x, y);
    }

    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();
}


function invertArrayValues(arr, maskZeros = false) {
    // Filter array to find min and max
    const filteredArr = maskZeros ? arr.filter(value => value !== 0) : arr;
    const min = Math.min(...filteredArr);
    const max = Math.max(...arr); // Max remains the same since we don't mask zeros for it

    // Return a new array with inverted values
    return arr.map(value => (value === 0 && maskZeros) ? 0 : max - (value - min));
}

function findMountainRange(array, maxNeighbours, threshold) {
    const midpoint = Math.floor(array.length / 2);
    let leftValleys = [];
    let rightValleys = [];

    const getNeighbours = (index, direction) => {
        let neighbours = [];
        for (let i = 1; i <= maxNeighbours; i++) {
            let neighbourIndex = index + i * direction;
            if (neighbourIndex >= 0 && neighbourIndex < array.length) {
                neighbours.push(array[neighbourIndex]);
            }
        }
        return neighbours;
    };

    // Check if there are any elements with value 0
    const hasZero = array.includes(0);

    if (hasZero) {
        // If the midpoint is 0, set range to the entire array
        if (array[midpoint] === 0) {
            return { startMountain: 0, endMountain: array.length - 1 };
        }

        // Otherwise, find the last non-zero element to the left and right of the midpoint
        let startMountain = 0;
        let endMountain = array.length - 1;

        for (let i = midpoint; i >= 0; i--) {
            if (array[i] !== 0) {
                startMountain = i;
            } else {
                break;
            }
        }

        for (let i = midpoint; i < array.length; i++) {
            if (array[i] !== 0) {
                endMountain = i;
            } else {
                break;
            }
        }

        return { startMountain, endMountain };
    }

    // No elements with value 0; continue with finding valleys
    for (let i = 0; i < array.length; i++) {
        const leftNeighbours = getNeighbours(i, -1);
        const rightNeighbours = getNeighbours(i, 1);

        const leftAvg = leftNeighbours.length
            ? leftNeighbours.reduce((a, b) => a + b, 0) / leftNeighbours.length
            : null;

        const rightAvg = rightNeighbours.length
            ? rightNeighbours.reduce((a, b) => a + b, 0) / rightNeighbours.length
            : null;

        const element = array[i];
        const avgLeft = leftAvg !== null ? leftAvg : rightAvg;
        const avgRight = rightAvg !== null ? rightAvg : leftAvg;

        if (
            avgLeft !== null &&
            avgRight !== null &&
            avgLeft > element * (1 + threshold / 100) &&
            avgRight > element * (1 + threshold / 100)
        ) {
            if (i < midpoint) {
                leftValleys.push(i);
            } else {
                rightValleys.push(i);
            }
        }
    }

    let startMountain, endMountain;

    if (leftValleys.length === 0) {
        startMountain = 0;
    } else {
        startMountain = leftValleys[leftValleys.length - 1];
    }

    if (rightValleys.length === 0) {
        endMountain = array.length - 1;
    } else {
        endMountain = rightValleys[0];
    }

    return { startMountain, endMountain };
}


function calculateMountainMetrics(array, start, end) {
    const mountain = array.slice(start, end + 1);
    const peakIndex = findPeakIndex(mountain) + start; // Adjust to original array index
    const peakHeight = array[peakIndex];

    // Calculate Mountain Properties
    const H = peakHeight - Math.min(...mountain); // Height
    const baseLevel = Math.min(...mountain);
    const Wbas = end - start;

    function calculateWidthAtHeight(heightPercent) {
        const heightThreshold = baseLevel + heightPercent * H;
        let left = start;
        let right = end;

        // Find the left boundary
        while (left <= end && array[left] < heightThreshold) {
            left++;
        }

        // Find the right boundary
        while (right >= start && array[right] < heightThreshold) {
            right--;
        }

        return right - left;
    }

    const W05 = calculateWidthAtHeight(0.5);
    const W01 = calculateWidthAtHeight(0.1);
    const W005 = calculateWidthAtHeight(0.05);

    // Calculate Area (S) using Trapezoidal Rule
    const S = mountain.reduce((area, value, index) => {
        if (index === 0) return area; // No segment before the first point
        const dx = 1; // Assuming unit spacing
        const avgHeight = (mountain[index] + mountain[index - 1]) / 2;
        return area + avgHeight * dx;
    }, 0);

    // Calculate A and B at 5% height
    const height05Threshold = baseLevel + 0.05 * H;
    const height10Threshold = baseLevel + 0.10 * H;
    const leftBoundary05 = findBoundaryAtHeight(array, start, peakIndex, height05Threshold, -1);
    const rightBoundary05 = findBoundaryAtHeight(array, peakIndex, end, height05Threshold, 1);
    const leftBoundary10 = findBoundaryAtHeight(array, start, peakIndex, height10Threshold, -1);
    const rightBoundary10 = findBoundaryAtHeight(array, peakIndex, end, height10Threshold, 1);    
    const A05 = peakIndex - leftBoundary05;
    const B05 = rightBoundary05 - peakIndex;
    const A10 = peakIndex - leftBoundary10;
    const B10 = rightBoundary10 - peakIndex;    

    // Calculate Factors
    const AsymmetryFactor = B10 / A10; // at 10% of height
    const TailingFactor = (A05 + B05) / (2 * A05); // at 5 % of height

    // Generate HTML
    const formulas = `
    <div>
        <p><strong>Asymmetry Factor (AF):</strong> AF = B / A = ${B10.toFixed(2)} / ${A10.toFixed(2)} = ${AsymmetryFactor.toFixed(2)}</p>
        <p><em>A and B are measured at 10% of the peak height.</em></p>
        <p><strong>Tailing Factor (TF):</strong> TF = (A + B) / (2 * A) = (${A05.toFixed(2)} + ${B05.toFixed(2)}) / (2 * ${A05.toFixed(2)}) = ${TailingFactor.toFixed(2)}</p>
        <p><em>A and B are measured at 5% of the peak height.</em></p>
    </div>
`;

    // Return Results
    const result = {
        H,
        Wbas,
        W05,
        W01,
        W005,
        S,
        A05,
        B05,
        A10,
        B10,        
        AsymmetryFactor,
        TailingFactor,
        formulas
    };
    return result;

    // Helper Functions
    function findPeakIndex(arr) {
        const maxVal = Math.max(...arr);
        const maxIndices = arr.map((val, idx) => (val === maxVal ? idx : -1)).filter(idx => idx !== -1);
        return Math.floor((maxIndices[0] + maxIndices[maxIndices.length - 1]) / 2); // Center of plateau if peak is flat
    }

    function findBoundaryAtHeight(array, start, end, height, direction) {
        let index = start;
        while (index !== end && array[index] >= height) {
            index += direction;
        }
        return index - direction; // Return the last valid index
    }
}

function objectToHtml(obj) {
    const rows = Object.entries(obj)
        .map(([key, value]) => `<tr><td>${key}</td><td>${value}</td></tr>`)
        .join('');
    return `<table border="1"><tbody>${rows}</tbody></table>`;
}

function drawVerticalLines(canvasId, startMountain, endMountain, dataLength) {
    // Get the canvas element and its context
    const canvas = document.getElementById(canvasId);
    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        console.error("Invalid canvas ID or element not found.");
        return;
    }

    const ctx = canvas.getContext("2d");
    if (!ctx) {
        console.error("Unable to get canvas context.");
        return;
    }

    // Calculate canvas positions for the lines
    const startX = (startMountain / dataLength) * canvas.width;
    const endX = (endMountain / dataLength) * canvas.width;

    // Set the line color and width
    ctx.strokeStyle = "green";
    ctx.lineWidth = 3;

    // Draw the first vertical line
    ctx.beginPath();
    ctx.moveTo(startX, 0);        // Start at the top of the canvas
    ctx.lineTo(startX, canvas.height); // End at the bottom of the canvas
    ctx.stroke();

    // Draw the second vertical line
    ctx.strokeStyle = "red";
    ctx.beginPath();
    ctx.moveTo(endX, 0);         // Start at the top of the canvas
    ctx.lineTo(endX, canvas.height); // End at the bottom of the canvas
    ctx.stroke();
}

// model management
function updateModelList() {
    modelList.innerHTML = '';
    const searchTerm = modelSearch.value.toLowerCase();
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(MODEL_PREFIX) && key.toLowerCase().includes(searchTerm)) {
            const li = document.createElement('li');
            li.textContent = key.substring(MODEL_PREFIX.length); // Display without prefix
            li.addEventListener('click', () => {
                modelNameInput.value = key.substring(MODEL_PREFIX.length);
            });
            modelList.appendChild(li);
        }
    }
}

saveButton.addEventListener('click', async () => {
    const modelName = modelNameInput.value;
    if (!modelName) {
        alert("Please enter a model name.");
        return;
    }

    const prefixedModelName = MODEL_PREFIX + modelName; // Add prefix

    if (localStorage.getItem(prefixedModelName)) {
        if (!confirm("Model with this name already exists. Do you want to overwrite it?")) {
            return;
        }
    }

    try {
        const modelData = await getSharableData();
        localStorage.setItem(prefixedModelName, JSON.stringify(modelData));
        updateModelList();
        modelNameInput.value = "";
        alert("Model saved!");
    } catch (error) {
        console.error("Error saving model:", error);
        alert("An error occurred while saving the model.");
    }
});

modelSearch.addEventListener('input', updateModelList);

window.addEventListener('storage', updateModelList);

copyAllButton.addEventListener('click', () => {
    const allModels = {};
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith(MODEL_PREFIX)) {
            allModels[key.substring(MODEL_PREFIX.length)] = JSON.parse(localStorage.getItem(key)); // Save without prefix in json
        }
    }
    navigator.clipboard.writeText(JSON.stringify(allModels)).then(() => {
        alert('All models data copied to clipboard!');
    });
});

pasteAllButton.addEventListener('click', () => {
    navigator.clipboard.readText().then(text => {
        try {
            const parsedModels = JSON.parse(text);
            for (const modelName in parsedModels) {
                localStorage.setItem(MODEL_PREFIX + modelName, JSON.stringify(parsedModels[modelName])); // Save with prefix in localstorage
            }
            updateModelList();
            alert('Models data pasted from clipboard!');
        } catch (error) {
            alert('Invalid data in clipboard. Please copy valid JSON model data.');
        }
    });
});

deleteButton.addEventListener('click', () => {
    const modelToDelete = modelNameInput.value;
    if (modelToDelete && confirm(`Are you sure you want to delete model "${modelToDelete}"?`)) {
        localStorage.removeItem(MODEL_PREFIX + modelToDelete); // Remove with prefix
        updateModelList();
        modelNameInput.value = "";
    }
});


applyButton.addEventListener('click', () => { // Event listener for apply button
    const modelName = modelNameInput.value;
    if (!modelName) {
        alert("Please select a model to apply.");
        return;
    }

    const prefixedModelName = MODEL_PREFIX + modelName;
    const storedModel = localStorage.getItem(prefixedModelName);

    if (storedModel) {
        try {
            const modelData = JSON.parse(storedModel);
            setSharableData(modelData); // Call the apply function
        } catch (error) {
            console.error("Error parsing model data:", error);
            alert("Error loading model data.");
        }
    } else {
        alert("Model not found.");
    }
});

updateModelList();


// raport code:
recordButton.addEventListener('click', () => {
    isRecording = !isRecording;
    recordButton.textContent = isRecording ? 'Stop Recording Report' : 'Start Recording Report';
    document.body.style.backgroundColor = isRecording ? 'Khaki' : raportColor;
});

clearButton.addEventListener('click', () => {
    reportContent.innerHTML = '';
    reportData = [];
});

function ReportaddText(text, element, page) {
    if (isRecording) {
        let p = document.createElement(element);
        p.textContent = text;
        page.appendChild(p);
    }
}

function ReportaddHTMLFromString(htmlString, element, page) {
    if (isRecording) {
        let div = document.createElement(element);
        div.innerHTML = htmlString;
        page.appendChild(div);
    }
}

function ReportaddImage(imageData, format, page) {
    if (isRecording) {
      const ctx = raportCanvas.getContext('2d');
      raportCanvas.width = imageData.width;
      raportCanvas.height = imageData.height;

      ctx.putImageData(imageData, 0, 0);

      let imageUrl;
      if (format.toLowerCase() === 'jpeg' || format.toLowerCase() === 'jpg') {
          imageUrl = raportCanvas.toDataURL('image/jpeg', 0.7); // Adjust quality (0-1) as needed
      } else if(format.toLowerCase() === 'png'){
          imageUrl = raportCanvas.toDataURL(`image/png`); // Use specified format (default png)
      }

      let img = document.createElement('img');
      img.src = imageUrl;
      page.appendChild(img);
    }
}

function ReportaddImageFromCanvas(canvas, format, page) {
    if (isRecording) {
      const ctx = canvas.getContext('2d');

      let imageUrl;
      if (format.toLowerCase() === 'jpeg' || format.toLowerCase() === 'jpg') {
          imageUrl = canvas.toDataURL('image/jpeg', 0.7); // Adjust quality (0-1) as needed
      } else if(format.toLowerCase() === 'png'){
          imageUrl = canvas.toDataURL(`image/png`); // Use specified format (default png)
      }

      let img = document.createElement('img');
      img.src = imageUrl;
      page.appendChild(img);
    }
}

function ReportaddTable(data, column_1_header, column_2_header, page) {
    if (isRecording) {
        let table = document.createElement('table');
        let headerRow = table.insertRow();

        const th1 = document.createElement('th');
        th1.textContent = column_1_header;
        headerRow.appendChild(th1);

        const th2 = document.createElement('th');
        th2.textContent = column_2_header;
        headerRow.appendChild(th2);

        // Use Object.entries to get key-value pairs
        for (const [key, value] of Object.entries(data)) {
          let row = table.insertRow(); // Create a single row
            let td1 = document.createElement('td');
            td1.textContent = key; // Display the value
            row.appendChild(td1);
            let td2 = document.createElement('td');
            td2.textContent = value; // Display the value
            row.appendChild(td2);
        }

        page.appendChild(table);
    }
}

async function generateHTML(mode) {
  try {
    generate_metadata();
    generate_summary();
    const doc = await exportReportContent();
    const blob = new Blob([doc], { type: "text/html" });
    if (mode === 'save') {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "report.html";
      a.click();
      URL.revokeObjectURL(a.href);
      return true;
    } else if (mode === 'share') {
      const fileName = RaportName.value.length > 0 ? `${RaportName.value}.report.html` : 'Report.html';
      const file = new File([blob], fileName, { type: 'text/html' });

      if (navigator.share) {
        try {
          await navigator.share({
            title: RaportName.value.length > 0 ? `${RaportName.value} Report` : 'QTLC Report',
            files: [file],
          });
          console.log('Shared successfully');
          return true;
        } catch (error) {
          console.error('Error sharing:', error);
          return false;
        }
      } else {
        alert('Web Share API is not supported in this browser.');
        return false;
      }
    }
  } catch (error) {
    console.error("Error generating HTML:", error);
    return false;
  }
}


async function exportReportContent() {
    if (!reportContent) {
        console.error("Element with ID 'reportContent' not found.");
        return;
    }

    const previewStyle = document.querySelectorAll('style')[1];

if (!previewStyle) {
    console.error("Preview style element not found.");
    return;
}

    const clone = reportContent.cloneNode(true);

    // Convert all <img> elements to use data URLs
    const images = clone.querySelectorAll("img");
    for (const img of images) {
        if (img.src.startsWith("data:")) continue; // Skip already embedded images
        try {
            const response = await fetch(img.src);
            const blob = await response.blob();
            const reader = new FileReader();

            await new Promise((resolve, reject) => {
                reader.onload = () => {
                    img.src = reader.result; // Replace src with data URL
                    resolve();
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        } catch (error) {
            console.error(`Failed to fetch image: ${img.src}`, error);
        }
    }

    // Wrap the cloned content in a complete HTML structure
    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report</title>
    <style>
${previewStyle.innerHTML}
    </style>
</head>
<body class="pdf">
    ${clone.innerHTML}
</body>
</html>
`;
}




function ReportaddPage(groupId, sectionType){
  if (isRecording) {
        let page = document.createElement('div');
        let hr = document.createElement('hr');
        page.classList.add("page");
        reportContent.appendChild(page);
        if (groupId) page.setAttribute('data-group-id', groupId);
        if (sectionType) page.setAttribute('data-section-type', sectionType); 
        page.id = generateUniqueUrl('nav');
        reportContent.appendChild(hr);
        return page;
    }
}

let previousText = savePdfButton.textContent;
let previousColor = savePdfButton.style.backgroundColor;

savePdfButton.addEventListener('click', async () => {
  savePdfButton.textContent = '(preparing report)';
  savePdfButton.style.backgroundColor = 'blue';
  const status = await generateHTML('save');
  savePdfButton.textContent = status ? '(report success)' : '(report failed)';
  savePdfButton.style.backgroundColor = status ? 'green' : 'red';
  // wait 0.5 s
  await new Promise(resolve => setTimeout(resolve, 500));
  savePdfButton.textContent = previousText;  // Reverting to default text
  savePdfButton.style.backgroundColor = previousColor;  // Reverting to default color
});

shareButton.addEventListener('click', async () => {
  let previousTextShare = shareButton.textContent;
  let previousColorShare = shareButton.style.backgroundColor;
  
  shareButton.textContent = '(preparing report)';
  shareButton.style.backgroundColor = 'blue';
  await generateHTML('share');
  savePdfButton.textContent = status ? '(report success)' : '(report failed)';
  savePdfButton.style.backgroundColor = status ? 'green' : 'red';
  // wait 0.5 s
  await new Promise(resolve => setTimeout(resolve, 500));
  shareButton.textContent = previousTextShare;
  shareButton.style.backgroundColor = previousColorShare;
});


function loadHtmlToReportContent() {
    const merge = MergeImportedReports.checked;
    const file = ReportfileInput.files[0];
    if (!file) {
        console.error("No file selected.");
        return;
    }

    const reader = new FileReader();

    reader.onload = () => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(reader.result, "text/html");

        // Extract body content
        const bodyContent = doc.body.innerHTML;

        // Find the reportContent element
        if (!reportContent) {
            console.error("Element with ID 'reportContent' not found.");
            return;
        }

        // Replace or merge content
        if (merge) {
          reportContent.innerHTML += bodyContent;
        } else {
          reportContent.innerHTML = bodyContent;
        }
    };

    reader.onerror = () => {
        console.error("Error reading file:", reader.error);
    };

    reader.readAsText(file);
}

function generate_metadata(){
  if (includeMetadata.checked) {

    const metadata = ReportaddPage(generateUniqueUrl('metadata'),'metadata');
    // Retrieve information from document head
    const version = document.head.querySelector('meta[name="version"]')?.content || 'N/A';
    const authors = document.head.querySelector('meta[name="authors"]')?.content || 'Unknown';
    
    // Get current date and time
    const currentDateTime = new Date().toLocaleString();

    const htmlData = `
        <h1>Web App Metadata</h1>
        <p><strong>App Version:</strong> ${version}</p>
        <p><strong>App Authors:</strong> ${authors}</p>
        <p><strong>Date and Time:</strong> ${currentDateTime}</p>
      `;

      ReportaddHTMLFromString(htmlData, 'div', metadata);    
  }
}

function generate_summary(){

  let summaries = document.querySelectorAll(`[data-section-type="summary"]`);
  summaries.forEach( sm =>{reportContent.removeChild(sm)}); //remove all summaries

  if (includeSummary.checked) {
    
      // Create the metadata section if it doesn't exist
    const  summary = ReportaddPage(generateUniqueUrl('summary'),'summary');

    if (!reportContent) {
          console.error('reportContent element not found.');
          return;
    }
    
    // Get all div elements with the class "page" within reportContent
    const pages = Array.from(reportContent.querySelectorAll('.page'));

    // Group elements by their data-group-id
    const groups = {};
    pages.forEach(page => {
        const groupId = page.getAttribute('data-group-id');
        const sectionType = page.getAttribute('data-section-type');
        const navigation = page.id;

        if (groupId && sectionType) {
            if (!groups[groupId]) {
                groups[groupId] = [];
            }
            groups[groupId].push({
                element: page,
                sectionType: sectionType,
                navigation: navigation
            });
        }
    });

    // Generate the list of content
    const contentList = document.createElement('ul');
    contentList.className = 'summary-content-list';
    let nr = 1;
    Object.entries(groups).forEach(([groupId, groupElements]) => {
        const groupItem = document.createElement('li');
        groupItem.textContent = `Operation: ${nr}`;
        nr ++;
        const groupSubList = document.createElement('ul');

        groupElements.forEach(({ element, sectionType, navigation }) => {
            const sectionItem = document.createElement('li');
            const link = document.createElement('a');
            link.textContent = sectionType;
            link.href = `#${navigation}`; // Ensure the element has an ID for navigation

            sectionItem.appendChild(link);
            groupSubList.appendChild(sectionItem);
        });

        groupItem.appendChild(groupSubList);
        contentList.appendChild(groupItem);
    });

    // Clear existing summary content and append the new list
    summary.innerHTML = '';
    summary.appendChild(contentList);

    // Move summary to the beginning of reportContent
    if (reportContent.firstChild !== summary) {
        reportContent.insertBefore(summary, reportContent.firstChild);
    }    
  }
}

function generateUniqueUrl(baseUrl) {
    const timestamp = Date.now(); // Current timestamp in milliseconds
    const randomNumber = Math.random().toString(36).substring(2, 10); // Random alphanumeric string
    return `${baseUrl}${timestamp}${randomNumber}`;
}


</script>

</body>
</html>